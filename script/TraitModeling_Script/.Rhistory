bractxx <- strsplit(as.character(bract), split = "+", fixed = T)
bractpp <- matrix(0, length(bract), 3, dimnames = list(names(bract), c("0", "1", "1+0")))
for (i in 1:nrow(bractpp)) bractpp[i,bractxx[[i]]]<-1/length(bractxx[[i]])
tiplabels(pie = bractpp, piecol = bractcols, cex=0.3)
par(fg="white")
piecol <- bractcols
for(i in 1:ncol(bractasr)){
bractnn <- strsplit(colnames(bractasr)[i],"+", fixed=TRUE)[[1]]
if(length(bractnn)==1) piecol[i] <- bractcols[bractnn]
else if(length(bractnn)==2) piecol[i] <- colorRampPalette(bractcols[bractnn])(3)[2]
else piecol[i]<-"black"
}
names(piecol)<-colnames(bractasr)
par(fg="white")
nodelabels(pie = bractasr, piecol = bractcols,cex=0.40)
par(fg="black")
legend("bottom", c("No Bract", "Bract"), pch = 21, pt.bg = c("firebrick1", "dodgerblue1"), pt.cex = 2, title = "Bract", cex = 1)
dev.off()
woody <- setNames(data$woody, rownames(data))
levels(woody) <- unique(data$woody)
woody.ER <- fitpolyMk(S, woody, model = "ER")
woodyxx <- apply(woody.ER$data,1,
function(x,ss) ss[which(x==1)],
ss=colnames(woody.ER$data))
woodyxx <- gsub("+","/", woodyxx, fixed=TRUE)
woody.data <- data.frame(Genus_sp = names(woodyxx), woody = woodyxx)
woody_rate.mat <- woody.ER$index.matrix
woody_rate.mat[woody_rate.mat==0] <- NA
colnames(woody_rate.mat) <- rownames(woody_rate.mat) <- gsub("+","/", colnames(woody_rate.mat), fixed=TRUE)
woodyind <- order(colnames(woody_rate.mat))
woody_rate.mat <- woody_rate.mat[woodyind, woodyind]
woody_fit.marginal <- corHMM(S, woody.data,
rate.mat = woody_rate.mat,
node.states = "marginal",
rate.cat = 1, p = woody.ER$rates,
root.p = woody.ER$pi)
woodyasr <- woody_fit.marginal$states
colnames(woodyasr) <- colnames(woody_rate.mat)
colnames(woodyasr) <- gsub("/","+", colnames(woodyasr))
svg("/home/guerbrown/github_local/biol-4386-course-project-guerbrown/output/inqcophy_traitmodeling_woody_guerbrown.svg", width = 20, height = 10)
woodypp <- matrix(0, length(woody), 3, dimnames = list(names(woody), c("0", "1", "1+0")))
plot.phylo(S, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
woodyX <- strsplit(setNames(as.character(woody_rate.mat), names(woody_rate.mat)),"+", fixed=TRUE)
pies <- matrix(0, Ntip(S),2,
dimnames=list(S$tip.label,
c("0", "1")))
for(i in 1:Ntip(S))
pies[S$tip.label[i],
woodyX[[S$tip.label[i]]]]<-
rep(1/length(woodyX[[S$tip.label[i]]]),
length(woodyX[[S$tip.label[i]]]))
woodycols <- setNames(c("firebrick1", "dodgerblue1"),
c("0", "1"))
par(fg="white")
woody <- setNames(data$woody, data$Synergus)
woodyxx <- strsplit(as.character(woody), split = "+", fixed = T)
woodypp <- matrix(0, length(woody), 3, dimnames = list(names(woody), c("0", "1", "1+0")))
for (i in 1:nrow(woodypp)) woodypp[i,woodyxx[[i]]]<-1/length(woodyxx[[i]])
tiplabels(pie = woodypp, piecol = woodycols, cex=0.3)
par(fg="white")
piecol <- woodycols
for(i in 1:ncol(woodyasr)){
woodynn <- strsplit(colnames(woodyasr)[i],"+", fixed=TRUE)[[1]]
if(length(woodynn)==1) piecol[i] <- woodycols[woodynn]
else if(length(woodynn)==2) piecol[i] <- colorRampPalette(woodycols[woodynn])(3)[2]
else piecol[i]<-"black"
}
names(piecol)<-colnames(woodyasr)
par(fg="white")
nodelabels(pie = woodyasr, piecol = woodycols,cex=0.40)
par(fg="black")
legend("bottom", c("Not Woody", "Woody"), pch = 21, pt.bg = c("firebrick1", "dodgerblue1"), pt.cex = 2, cex = 1)
dev.off()
fleshy <- setNames(data$fleshy, rownames(data))
levels(fleshy) <- unique(data$fleshy)
fleshy.ER <- fitpolyMk(S, fleshy, model = "ER")
fleshyxx <- apply(fleshy.ER$data,1,
function(x,ss) ss[which(x==1)],
ss=colnames(fleshy.ER$data))
fleshyxx <- gsub("+","/", fleshyxx, fixed=TRUE)
fleshy.data <- data.frame(Genus_sp = names(fleshyxx), fleshy = fleshyxx)
fleshy_rate.mat <- fleshy.ER$index.matrix
fleshy_rate.mat[fleshy_rate.mat==0] <- NA
colnames(fleshy_rate.mat) <- rownames(fleshy_rate.mat) <- gsub("+","/", colnames(fleshy_rate.mat), fixed=TRUE)
fleshyind <- order(colnames(fleshy_rate.mat))
fleshy_rate.mat <- fleshy_rate.mat[fleshyind, fleshyind]
fleshy_fit.marginal <- corHMM(S, fleshy.data,
rate.mat = fleshy_rate.mat,
node.states = "marginal",
rate.cat = 1, p = fleshy.ER$rates,
root.p = fleshy.ER$pi)
fleshyasr <- fleshy_fit.marginal$states
colnames(fleshyasr) <- colnames(fleshy_rate.mat)
colnames(fleshyasr) <- gsub("/","+", colnames(fleshyasr))
svg("/home/guerbrown/github_local/biol-4386-course-project-guerbrown/output/inqcophy_traitmodeling_fleshy_guerbrown.svg", width = 20, height = 10)
fleshypp <- matrix(0, length(fleshy), 3, dimnames = list(names(fleshy), c("0", "1", "1+0")))
plot.phylo(S, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
fleshyX <- strsplit(setNames(as.character(fleshy_rate.mat), names(fleshy_rate.mat)),"+", fixed=TRUE)
pies <- matrix(0, Ntip(S),2,
dimnames=list(S$tip.label,
c("0", "1")))
for(i in 1:Ntip(S))
pies[S$tip.label[i],
fleshyX[[S$tip.label[i]]]]<-
rep(1/length(fleshyX[[S$tip.label[i]]]),
length(fleshyX[[S$tip.label[i]]]))
fleshycols <- setNames(c("firebrick1", "dodgerblue1", "grey15"),
c("0", "1"))
par(fg="white")
fleshy <- setNames(data$fleshy, data$Synergus)
fleshyxx <- strsplit(as.character(fleshy), split = "+", fixed = T)
fleshypp <- matrix(0, length(fleshy), 3, dimnames = list(names(fleshy), c("0", "1", "1+0")))
for (i in 1:nrow(fleshypp)) fleshypp[i,fleshyxx[[i]]]<-1/length(fleshyxx[[i]])
tiplabels(pie = fleshypp, piecol = fleshycols, cex=0.3)
par(fg="white")
piecol <- fleshycols
for(i in 1:ncol(fleshyasr)){
fleshynn <- strsplit(colnames(fleshyasr)[i],"+", fixed=TRUE)[[1]]
if(length(fleshynn)==1) piecol[i] <- fleshycols[fleshynn]
else if(length(fleshynn)==2) piecol[i] <- colorRampPalette(fleshycols[fleshynn])(3)[2]
else piecol[i]<-"black"
}
names(piecol)<-colnames(fleshyasr)
par(fg="white")
nodelabels(pie = fleshyasr, piecol = fleshycols,cex=0.40)
par(fg="black")
legend("bottom", c("Not Fleshy", "Fleshy", "Both"), pch = 21, pt.bg = c("firebrick1", "dodgerblue1", "grey15"), pt.cex = 2, cex = 1)
dev.off()
season <- setNames(data$season, rownames(data))
levels(season) <- unique(data$season)
season.ER <- fitpolyMk(S, season, model = "ER")
seasonxx <- apply(season.ER$data,1,
function(x,ss) ss[which(x==1)],
ss=colnames(season.ER$data))
seasonxx <- gsub("+","/", seasonxx, fixed=TRUE)
season.data <- data.frame(Genus_sp = names(seasonxx), season = seasonxx)
season_rate.mat <- season.ER$index.matrix
season_rate.mat[season_rate.mat==0] <- NA
colnames(season_rate.mat) <- rownames(season_rate.mat) <- gsub("+","/", colnames(season_rate.mat), fixed=TRUE)
seasonind <- order(colnames(season_rate.mat))
season_rate.mat <- season_rate.mat[seasonind, seasonind]
season_fit.marginal <- corHMM(S, season.data,
rate.mat = season_rate.mat,
node.states = "marginal",
rate.cat = 1, p = season.ER$rates,
root.p = season.ER$pi)
seasonasr <- season_fit.marginal$states
colnames(seasonasr) <- colnames(season_rate.mat)
colnames(seasonasr) <- gsub("/","+", colnames(seasonasr))
svg("/home/guerbrown/github_local/biol-4386-course-project-guerbrown/output/inqcophy_traitmodeling_season_guerbrown.svg", width = 20, height = 10)
seasonpp <- matrix(0, length(season), 3, dimnames = list(names(season), c("3", "2", "2+3")))
plot.phylo(S, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
seasonX <- strsplit(setNames(as.character(season_rate.mat), names(season_rate.mat)),"+", fixed=TRUE)
pies <- matrix(0, Ntip(S),3,
dimnames=list(S$tip.label,
c("3", "2", "2+3")))
for(i in 1:Ntip(S))
pies[S$tip.label[i],
seasonX[[S$tip.label[i]]]]<-
rep(1/length(seasonX[[S$tip.label[i]]]),
length(seasonX[[S$tip.label[i]]]))
seasoncols <- setNames(c("firebrick1", "dodgerblue1", "grey15"),
c("0", "1"))
par(fg="white")
season <- setNames(data$season, data$Synergus)
seasonxx <- strsplit(as.character(season), split = "+", fixed = T)
seasonpp <- matrix(0, length(season), 3, dimnames = list(names(season), c("3", "2", "2+3")))
for (i in 1:nrow(seasonpp)) seasonpp[i,seasonxx[[i]]]<-1/length(seasonxx[[i]])
tiplabels(pie = seasonpp, piecol = seasoncols, cex=0.3)
par(fg="white")
piecol <- seasoncols
for(i in 1:ncol(seasonasr)){
seasonnn <- strsplit(colnames(seasonasr)[i],"+", fixed=TRUE)[[1]]
if(length(seasonnn)==1) piecol[i] <- seasoncols[seasonnn]
else if(length(seasonnn)==2) piecol[i] <- colorRampPalette(seasoncols[seasonnn])(3)[2]
else piecol[i]<-"black"
}
names(piecol)<-colnames(seasonasr)
par(fg="white")
nodelabels(pie = seasonasr, piecol = seasoncols,cex=0.40)
par(fg="black")
legend("bottom", c("Fall", "Summer", "Fall+Summer"), pch = 21, pt.bg = c("firebrick1", "dodgerblue1", "grey15"), pt.cex = 2, title = "Season", cex = 1)
dev.off()
location <- setNames(data$location, rownames(data))
levels(location) <- unique(data$location)
location.ER <- fitpolyMk(S, location, model = "ER")
locationxx <- apply(location.ER$data,1,
function(x,ss) ss[which(x==1)],
ss=colnames(location.ER$data))
locationxx <- gsub("+","/", locationxx, fixed=TRUE)
location.data <- data.frame(Genus_sp = names(locationxx), location = locationxx)
location_rate.mat <- location.ER$index.matrix
location_rate.mat[location_rate.mat==0] <- NA
colnames(location_rate.mat) <- rownames(location_rate.mat) <- gsub("+","/", colnames(location_rate.mat), fixed=TRUE)
locationind <- order(colnames(location_rate.mat))
location_rate.mat <- location_rate.mat[locationind, locationind]
location_fit.marginal <- corHMM(S, location.data,
rate.mat = location_rate.mat,
node.states = "marginal",
rate.cat = 1, p = location.ER$rates,
root.p = location.ER$pi)
locationasr <- location_fit.marginal$states
colnames(locationasr) <- colnames(location_rate.mat)
colnames(locationasr) <- gsub("/","+", colnames(locationasr))
locationasr[,"acorn"] <- locationasr[,"acorn"] + 1/2*(locationasr)[,2] + 1/3*(locationasr[,3]) + 1/4*(locationasr[,4]) + 1/5*(locationasr[,5]) + 1/4*(locationasr[,6]) + 1/3*(locationasr[,7]) + 1/4*(locationasr[,8]) + 1/3*(locationasr[,9]) + 1/2*(locationasr[,10]) + 1/3*(locationasr[,11]) + 1/4*(locationasr[,12]) + 1/3*(locationasr[,13]) + 1/2*(locationasr[,14]) + 1/3*(locationasr[,15]) + 1/2*(locationasr[,16])
locationasr[,"bud"] <- locationasr[,"bud"] + 1/2*(locationasr)[,2] + 1/3*(locationasr[,3]) + 1/4*(locationasr[,4]) + 1/5*(locationasr[,5]) + 1/4*(locationasr[,6]) + 1/3*(locationasr[,7]) + 1/4*(locationasr[,8]) + 1/3*(locationasr[,9]) + 1/2*(locationasr[,18]) + 1/3*(locationasr[,19]) + 1/4*(locationasr[,20]) + 1/3*(locationasr[,21]) + 1/2*(locationasr[,22]) + 1/3*(locationasr[,23]) + 1/2*(locationasr[,24])
locationasr[,"leaf"] <- locationasr[,"leaf"] + 1/3*(locationasr[,3]) + 1/4*(locationasr[,4]) + 1/5*(locationasr[,5]) + 1/4*(locationasr[,6]) + 1/2*(locationasr[,10]) + 1/3*(locationasr[,11]) + 1/4*(locationasr[,12]) + 1/3*(locationasr[,13]) + 1/2*(locationasr[,18]) + 1/3*(locationasr[,19]) + 1/4*(locationasr[,20]) + 1/3*(locationasr[,21]) + 1/2*(locationasr[,26]) + 1/3*(locationasr[,27]) + 1/2*(locationasr[,28])
locationasr[,"petiole"] <- locationasr[,"petiole"] + 1/4*(locationasr[,4]) + 1/5*(locationasr[,5]) + 1/3*(locationasr[,7]) + 1/4*(locationasr[,8]) + 1/3*(locationasr[,11]) + 1/4*(locationasr[,12]) + 1/3*(locationasr[,15]) + 1/3*(locationasr[,19]) + 1/4*(locationasr[,20]) + 1/2*(locationasr[,22]) + 1/3*(locationasr[,23]) + 1/2*(locationasr[,26]) + 1/3*(locationasr[,27]) + 1/2*(locationasr[,30])
locationasr[,"stem"] <- locationasr[,"stem"] + 1/5*(locationasr[,5]) + 1/4*(locationasr[,6]) + 1/4*(locationasr[,8]) + 1/3*(locationasr[,9]) + 1/4*(locationasr[,12]) + 1/3*(locationasr[,13]) + 1/3*(locationasr[,15]) + 1/2*(locationasr[,16]) + 1/4*(locationasr[,20]) + 1/3*(locationasr[,21]) + 1/3*(locationasr[,23]) + 1/2*(locationasr[,24]) + 1/3*(locationasr[,27]) + 1/2*(locationasr[,28]) + 1/2*(locationasr[,30])
locationasr <- data.frame(locationasr[,"acorn"], locationasr[,"bud"], locationasr[,"leaf"], locationasr[,"petiole"], locationasr[,"stem"])
#svg("/home/guerbrown/github_local/biol-4386-course-project-guerbrown/output/inqcophy_traitmodeling_location_guerbrown.svg", width = 20, height = 10)
locationpp <- matrix(0, length(location), 5, dimnames = list(names(location), c("acorn", "bud", "leaf", "petiole", "stem")))
plot.phylo(S, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
locationX <- strsplit(setNames(as.character(location_rate.mat), names(location_rate.mat)),"+", fixed=TRUE)
pies <- matrix(0, Ntip(S),5,
dimnames=list(S$tip.label,
c("acorn", "bud", "leaf", "petiole", "stem")))
for(i in 1:Ntip(S))
pies[S$tip.label[i],
locationX[[S$tip.label[i]]]]<-
rep(1/length(locationX[[S$tip.label[i]]]),
length(locationX[[S$tip.label[i]]]))
locationcols <- setNames(c("firebrick1", "dodgerblue1", "gold1", "grey15", "green"),
c("0", "1"))
par(fg="white")
location <- setNames(data$location, data$Synergus)
locationxx <- strsplit(as.character(location), split = "+", fixed = T)
locationpp <- matrix(0, length(location), 5, dimnames = list(names(location), c("acorn", "bud", "leaf", "petiole", "stem")))
for (i in 1:nrow(locationpp)) locationpp[i,locationxx[[i]]]<-1/length(locationxx[[i]])
tiplabels(pie = locationpp, piecol = locationcols, cex=0.3)
par(fg="white")
piecol <- locationcols
for(i in 1:ncol(locationasr)){
locationnn <- strsplit(colnames(locationasr)[i],"+", fixed=TRUE)[[1]]
if(length(locationnn)==1) piecol[i] <- locationcols[locationnn]
else if(length(locationnn)==2) piecol[i] <- colorRampPalette(locationcols[locationnn])(3)[2]
else piecol[i]<-"black"
}
names(piecol)<-colnames(locationasr)
par(fg="white")
nodelabels(pie = locationasr, piecol = locationcols,cex=0.40)
par(fg="black")
legend("bottom", c("acorn", "bud", "leaf", "petiole", "stem"), pch = 21, pt.bg = c(locationcols), pt.cex = 2, title = "location", cex = 1)
#dev.off()
# First, lets isolate the variable we want to graphically model from the original imported data frame
oak_section <- setNames(data$oak_section, rownames(data))
# Rename the levels of the variable
levels(oak_section) <- unique(data$oak_section)
# Recapitulation of the best fit model (see model selection script)
oak_section.ER <- ace(oak_section, S, model = "ER", type = "discrete")
# The model currenlty includes an intermediate state, let's break this intermediate state into the two discrete traits.
oak_section.ER$lik.anc[,1] <- oak_section.ER$lik.anc[,1] + 1/2*(oak_section.ER$lik.anc[,4])
oak_section.ER$lik.anc[,2] <- oak_section.ER$lik.anc[,2] + 1/2*(oak_section.ER$lik.anc[,4])
oak_section.ER$lik.anc <- data.frame(oak_section.ER$lik.anc[,1],oak_section.ER$lik.anc[,2], oak_section.ER$lik.anc[,3])
# Set colors for the pie charts
oak_sectioncols <- c("firebrick1", "dodgerblue1", "grey15")
# Now we have the data organized in a way that makes it accessible to the program and we can begin computing the graphical output of the figure. First, I want to save these automatically as vector graphics, so I'll use this function to initiate it.
svg("/home/guerbrown/github_local/biol-4386-course-project-guerbrown/output/inqcophy_traitmodeling_oak_section_guerbrown.svg", width = 20, height = 10)
# Plot the tree in a phylo space with the layout of your choosing
plot.phylo(S, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
# Create a simple data frame with the variables based on the taxa
oak_section_DATA <- setNames(data$oak_section, data$Synergus)
# Split the names of the variable names and list a new object
oak_sectionxx <- strsplit(as.character(oak_section_DATA), split = "+", fixed = T)
# Create a matrix with the variables from the _DATA file by providing lists of occurrence or absence of particular variables for each taxa
oak_sectionpp <- matrix(0, length(oak_section_DATA), 4, dimnames = list(names(oak_section_DATA), c("Lobatae","Quercus", "Virentes", "Quercus+Virentes")))
# Convert this matrix into a matrix of percentages by marking presence as 1 and divide it by the length of the data frame, effectively providign a value of the proportion
for (i in 1:nrow(oak_sectionpp)) oak_sectionpp[i,oak_sectionxx[[i]]]<-1/length(oak_sectionxx[[i]])
par(fg = "transparent")
# Adding tip labels using this proportional matrix using the previously listed colors
ape::tiplabels(pie = oak_sectionpp, piecol = oak_sectioncols, cex = 0.3)
par(fg = "white")
# Addingthe node labels based on our likely ancestor from the model recapitulation.
nodelabels( node = 1:S$Nnode+Ntip(S),
pie = oak_section.ER$lik.anc, piecol = oak_sectioncols, cex=0.4)
par(fg = "black")
# Providing a legend
legend("bottom", c("Red Oaks (sect. Lobatae)", "White Oaks (sect. Quercus)", "Live Oaks (sect. Virentes)"), pch = 21, pt.bg = c("firebrick1", "dodgerblue1", "grey15"), pt.cex = 2, title = "Oak Section", cex = 1)
# Telling the program we are done creating an image. This results in whatever is plotted being saved
dev.off()
# First, lets isolate the variable we want to graphically model from the original imported data frame
oak_section <- setNames(data$oak_section, rownames(data))
# Rename the levels of the variable
levels(oak_section) <- unique(data$oak_section)
# Recapitulation of the best fit model (see model selection script)
oak_section.ER <- ace(oak_section, S, model = "ER", type = "discrete")
# The model currenlty includes an intermediate state, let's break this intermediate state into the two discrete traits.
oak_section.ER$lik.anc[,1] <- oak_section.ER$lik.anc[,1] + 1/2*(oak_section.ER$lik.anc[,4])
oak_section.ER$lik.anc[,2] <- oak_section.ER$lik.anc[,2] + 1/2*(oak_section.ER$lik.anc[,4])
oak_section.ER$lik.anc <- data.frame(oak_section.ER$lik.anc[,1],oak_section.ER$lik.anc[,2], oak_section.ER$lik.anc[,3])
# Set colors for the pie charts
oak_sectioncols <- c("firebrick1", "dodgerblue1", "grey15")
# Now we have the data organized in a way that makes it accessible to the program and we can begin computing the graphical output of the figure. First, I want to save these automatically as vector graphics, so I'll use this function to initiate it.
svg("/home/guerbrown/github_local/biol-4386-course-project-guerbrown/output/inqcophy_traitmodeling_oak_section_guerbrown.svg", width = 20, height = 10)
# Plot the tree in a phylo space with the layout of your choosing
plot.phylo(S, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
# Create a simple data frame with the variables based on the taxa
oak_section_DATA <- setNames(data$oak_section, data$Synergus)
# Split the names of the variable names and list a new object
oak_sectionxx <- strsplit(as.character(oak_section_DATA), split = "+", fixed = T)
# Create a matrix with the variables from the _DATA file by providing lists of occurrence or absence of particular variables for each taxa
oak_sectionpp <- matrix(0, length(oak_section_DATA), 4, dimnames = list(names(oak_section_DATA), c("Lobatae","Quercus", "Virentes", "Quercus+Virentes")))
# Convert this matrix into a matrix of percentages by marking presence as 1 and divide it by the length of the data frame, effectively providign a value of the proportion
for (i in 1:nrow(oak_sectionpp)) oak_sectionpp[i,oak_sectionxx[[i]]]<-1/length(oak_sectionxx[[i]])
par(fg = "transparent")
# Adding tip labels using this proportional matrix using the previously listed colors
ape::tiplabels(pie = oak_sectionpp, piecol = oak_sectioncols, cex = 0.25)
par(fg = "white")
# Addingthe node labels based on our likely ancestor from the model recapitulation.
nodelabels( node = 1:S$Nnode+Ntip(S),
pie = oak_section.ER$lik.anc, piecol = oak_sectioncols, cex=0.4)
par(fg = "black")
# Providing a legend
legend("bottom", c("Red Oaks (sect. Lobatae)", "White Oaks (sect. Quercus)", "Live Oaks (sect. Virentes)"), pch = 21, pt.bg = c("firebrick1", "dodgerblue1", "grey15"), pt.cex = 2, title = "Oak Section", cex = 1)
# Telling the program we are done creating an image. This results in whatever is plotted being saved
dev.off()
# First, lets isolate the variable we want to graphically model from the original imported data frame
oak_section <- setNames(data$oak_section, rownames(data))
# Rename the levels of the variable
levels(oak_section) <- unique(data$oak_section)
# Recapitulation of the best fit model (see model selection script)
oak_section.ER <- ace(oak_section, S, model = "ER", type = "discrete")
# The model currenlty includes an intermediate state, let's break this intermediate state into the two discrete traits.
oak_section.ER$lik.anc[,1] <- oak_section.ER$lik.anc[,1] + 1/2*(oak_section.ER$lik.anc[,4])
oak_section.ER$lik.anc[,2] <- oak_section.ER$lik.anc[,2] + 1/2*(oak_section.ER$lik.anc[,4])
oak_section.ER$lik.anc <- data.frame(oak_section.ER$lik.anc[,1],oak_section.ER$lik.anc[,2], oak_section.ER$lik.anc[,3])
# Set colors for the pie charts
oak_sectioncols <- c("firebrick1", "grey50", "dodgerblue")
# Now we have the data organized in a way that makes it accessible to the program and we can begin computing the graphical output of the figure. First, I want to save these automatically as vector graphics, so I'll use this function to initiate it.
svg("/home/guerbrown/github_local/biol-4386-course-project-guerbrown/output/inqcophy_traitmodeling_oak_section_guerbrown.svg", width = 20, height = 10)
# Plot the tree in a phylo space with the layout of your choosing
plot.phylo(S, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
# Create a simple data frame with the variables based on the taxa
oak_section_DATA <- setNames(data$oak_section, data$Synergus)
# Split the names of the variable names and list a new object
oak_sectionxx <- strsplit(as.character(oak_section_DATA), split = "+", fixed = T)
# Create a matrix with the variables from the _DATA file by providing lists of occurrence or absence of particular variables for each taxa
oak_sectionpp <- matrix(0, length(oak_section_DATA), 4, dimnames = list(names(oak_section_DATA), c("Lobatae","Quercus", "Virentes", "Quercus+Virentes")))
# Convert this matrix into a matrix of percentages by marking presence as 1 and divide it by the length of the data frame, effectively providign a value of the proportion
for (i in 1:nrow(oak_sectionpp)) oak_sectionpp[i,oak_sectionxx[[i]]]<-1/length(oak_sectionxx[[i]])
par(fg = "transparent")
# Adding tip labels using this proportional matrix using the previously listed colors
ape::tiplabels(pie = oak_sectionpp, piecol = oak_sectioncols, cex = 0.25)
par(fg = "white")
# Addingthe node labels based on our likely ancestor from the model recapitulation.
nodelabels( node = 1:S$Nnode+Ntip(S),
pie = oak_section.ER$lik.anc, piecol = oak_sectioncols, cex=0.4)
par(fg = "black")
# Providing a legend
legend("bottom", c("Red Oaks (sect. Lobatae)", "White Oaks (sect. Quercus)", "Live Oaks (sect. Virentes)"), pch = 21, pt.bg = c(oak_sectioncols), pt.cex = 2, title = "Oak Section", cex = 1)
# Telling the program we are done creating an image. This results in whatever is plotted being saved
dev.off()
# First, lets isolate the variable we want to graphically model from the original imported data frame
oak_section <- setNames(data$oak_section, rownames(data))
# Rename the levels of the variable
levels(oak_section) <- unique(data$oak_section)
# Recapitulation of the best fit model (see model selection script)
oak_section.ER <- ace(oak_section, S, model = "ER", type = "discrete")
# The model currenlty includes an intermediate state, let's break this intermediate state into the two discrete traits.
oak_section.ER$lik.anc[,1] <- oak_section.ER$lik.anc[,1] + 1/2*(oak_section.ER$lik.anc[,4])
oak_section.ER$lik.anc[,2] <- oak_section.ER$lik.anc[,2] + 1/2*(oak_section.ER$lik.anc[,4])
oak_section.ER$lik.anc <- data.frame(oak_section.ER$lik.anc[,1],oak_section.ER$lik.anc[,2], oak_section.ER$lik.anc[,3])
# Set colors for the pie charts
oak_sectioncols <- c("firebrick1", "grey50", "dodgerblue")
# Now we have the data organized in a way that makes it accessible to the program and we can begin computing the graphical output of the figure. First, I want to save these automatically as vector graphics, so I'll use this function to initiate it.
svg("/home/guerbrown/github_local/biol-4386-course-project-guerbrown/output/inqcophy_traitmodeling_oak_section_guerbrown.svg", width = 20, height = 10)
# Plot the tree in a phylo space with the layout of your choosing
plot.phylo(S, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = T, open.angle =  163, node.depth = 100)
# Create a simple data frame with the variables based on the taxa
oak_section_DATA <- setNames(data$oak_section, data$Synergus)
# Split the names of the variable names and list a new object
oak_sectionxx <- strsplit(as.character(oak_section_DATA), split = "+", fixed = T)
# Create a matrix with the variables from the _DATA file by providing lists of occurrence or absence of particular variables for each taxa
oak_sectionpp <- matrix(0, length(oak_section_DATA), 4, dimnames = list(names(oak_section_DATA), c("Lobatae","Quercus", "Virentes", "Quercus+Virentes")))
# Convert this matrix into a matrix of percentages by marking presence as 1 and divide it by the length of the data frame, effectively providign a value of the proportion
for (i in 1:nrow(oak_sectionpp)) oak_sectionpp[i,oak_sectionxx[[i]]]<-1/length(oak_sectionxx[[i]])
par(fg = "transparent")
# Adding tip labels using this proportional matrix using the previously listed colors
ape::tiplabels(pie = oak_sectionpp, piecol = oak_sectioncols, cex = 0.25)
par(fg = "white")
# Addingthe node labels based on our likely ancestor from the model recapitulation.
nodelabels( node = 1:S$Nnode+Ntip(S),
pie = oak_section.ER$lik.anc, piecol = oak_sectioncols, cex=0.4)
par(fg = "black")
# Providing a legend
legend("bottom", c("Red Oaks (sect. Lobatae)", "White Oaks (sect. Quercus)", "Live Oaks (sect. Virentes)"), pch = 21, pt.bg = c(oak_sectioncols), pt.cex = 2, title = "Oak Section", cex = 1)
# Telling the program we are done creating an image. This results in whatever is plotted being saved
dev.off()
# First, lets isolate the variable we want to graphically model from the original imported data frame
oak_section <- setNames(data$oak_section, rownames(data))
# Rename the levels of the variable
levels(oak_section) <- unique(data$oak_section)
# Recapitulation of the best fit model (see model selection script)
oak_section.ER <- ace(oak_section, S, model = "ER", type = "discrete")
# The model currenlty includes an intermediate state, let's break this intermediate state into the two discrete traits.
oak_section.ER$lik.anc[,1] <- oak_section.ER$lik.anc[,1] + 1/2*(oak_section.ER$lik.anc[,4])
oak_section.ER$lik.anc[,2] <- oak_section.ER$lik.anc[,2] + 1/2*(oak_section.ER$lik.anc[,4])
oak_section.ER$lik.anc <- data.frame(oak_section.ER$lik.anc[,1],oak_section.ER$lik.anc[,2], oak_section.ER$lik.anc[,3])
# Set colors for the pie charts
oak_sectioncols <- c("firebrick1", "grey50", "dodgerblue")
# Now we have the data organized in a way that makes it accessible to the program and we can begin computing the graphical output of the figure. First, I want to save these automatically as vector graphics, so I'll use this function to initiate it.
svg("/home/guerbrown/github_local/biol-4386-course-project-guerbrown/output/inqcophy_traitmodeling_oak_section_guerbrown.svg", width = 20, height = 10)
# Plot the tree in a phylo space with the layout of your choosing
plot.phylo(S, type = "", cex = 1.1, align.tip.label = T, lwd = 2, label.offset = 0.01, use.edge.length = T, open.angle =  163, node.depth = 100)
# First, lets isolate the variable we want to graphically model from the original imported data frame
oak_section <- setNames(data$oak_section, rownames(data))
# Rename the levels of the variable
levels(oak_section) <- unique(data$oak_section)
# Recapitulation of the best fit model (see model selection script)
oak_section.ER <- ace(oak_section, S, model = "ER", type = "discrete")
# The model currenlty includes an intermediate state, let's break this intermediate state into the two discrete traits.
oak_section.ER$lik.anc[,1] <- oak_section.ER$lik.anc[,1] + 1/2*(oak_section.ER$lik.anc[,4])
oak_section.ER$lik.anc[,2] <- oak_section.ER$lik.anc[,2] + 1/2*(oak_section.ER$lik.anc[,4])
oak_section.ER$lik.anc <- data.frame(oak_section.ER$lik.anc[,1],oak_section.ER$lik.anc[,2], oak_section.ER$lik.anc[,3])
# Set colors for the pie charts
oak_sectioncols <- c("firebrick1", "grey50", "dodgerblue")
# Now we have the data organized in a way that makes it accessible to the program and we can begin computing the graphical output of the figure. First, I want to save these automatically as vector graphics, so I'll use this function to initiate it.
svg("/home/guerbrown/github_local/biol-4386-course-project-guerbrown/output/inqcophy_traitmodeling_oak_section_guerbrown.svg", width = 20, height = 10)
# Plot the tree in a phylo space with the layout of your choosing
plot.phylo(S, type = "fan", cex = 1.1, align.tip.label = T, lwd = 2, label.offset = 0.01, use.edge.length = T, open.angle =  163, node.depth = 100)
# Create a simple data frame with the variables based on the taxa
oak_section_DATA <- setNames(data$oak_section, data$Synergus)
# Split the names of the variable names and list a new object
oak_sectionxx <- strsplit(as.character(oak_section_DATA), split = "+", fixed = T)
# Create a matrix with the variables from the _DATA file by providing lists of occurrence or absence of particular variables for each taxa
oak_sectionpp <- matrix(0, length(oak_section_DATA), 4, dimnames = list(names(oak_section_DATA), c("Lobatae","Quercus", "Virentes", "Quercus+Virentes")))
# Convert this matrix into a matrix of percentages by marking presence as 1 and divide it by the length of the data frame, effectively providign a value of the proportion
for (i in 1:nrow(oak_sectionpp)) oak_sectionpp[i,oak_sectionxx[[i]]]<-1/length(oak_sectionxx[[i]])
par(fg = "transparent")
# Adding tip labels using this proportional matrix using the previously listed colors
ape::tiplabels(pie = oak_sectionpp, piecol = oak_sectioncols, cex = 0.1)
par(fg = "white")
# Addingthe node labels based on our likely ancestor from the model recapitulation.
nodelabels( node = 1:S$Nnode+Ntip(S),
pie = oak_section.ER$lik.anc, piecol = oak_sectioncols, cex=0.2)
par(fg = "black")
# Providing a legend
legend("bottom", c("Red Oaks (sect. Lobatae)", "White Oaks (sect. Quercus)", "Live Oaks (sect. Virentes)"), pch = 21, pt.bg = c(oak_sectioncols), pt.cex = 2, title = "Oak Section", cex = 1)
# Telling the program we are done creating an image. This results in whatever is plotted being saved
dev.off()
# First, lets isolate the variable we want to graphically model from the original imported data frame
oak_section <- setNames(data$oak_section, rownames(data))
# Rename the levels of the variable
levels(oak_section) <- unique(data$oak_section)
# Recapitulation of the best fit model (see model selection script)
oak_section.ER <- ace(oak_section, S, model = "ER", type = "discrete")
# The model currenlty includes an intermediate state, let's break this intermediate state into the two discrete traits.
oak_section.ER$lik.anc[,1] <- oak_section.ER$lik.anc[,1] + 1/2*(oak_section.ER$lik.anc[,4])
oak_section.ER$lik.anc[,2] <- oak_section.ER$lik.anc[,2] + 1/2*(oak_section.ER$lik.anc[,4])
oak_section.ER$lik.anc <- data.frame(oak_section.ER$lik.anc[,1],oak_section.ER$lik.anc[,2], oak_section.ER$lik.anc[,3])
# Set colors for the pie charts
oak_sectioncols <- c("firebrick1", "grey50", "dodgerblue")
# Now we have the data organized in a way that makes it accessible to the program and we can begin computing the graphical output of the figure. First, I want to save these automatically as vector graphics, so I'll use this function to initiate it.
svg("/home/guerbrown/github_local/biol-4386-course-project-guerbrown/output/inqcophy_traitmodeling_oak_section_guerbrown.svg", width = 20, height = 10)
# Plot the tree in a phylo space with the layout of your choosing
plot.phylo(S, cex = 1.1, align.tip.label = T, lwd = 2, label.offset = 0.01, use.edge.length = T, open.angle =  163, node.depth = 100)
# Create a simple data frame with the variables based on the taxa
oak_section_DATA <- setNames(data$oak_section, data$Synergus)
# Split the names of the variable names and list a new object
oak_sectionxx <- strsplit(as.character(oak_section_DATA), split = "+", fixed = T)
# Create a matrix with the variables from the _DATA file by providing lists of occurrence or absence of particular variables for each taxa
oak_sectionpp <- matrix(0, length(oak_section_DATA), 4, dimnames = list(names(oak_section_DATA), c("Lobatae","Quercus", "Virentes", "Quercus+Virentes")))
# Convert this matrix into a matrix of percentages by marking presence as 1 and divide it by the length of the data frame, effectively providign a value of the proportion
for (i in 1:nrow(oak_sectionpp)) oak_sectionpp[i,oak_sectionxx[[i]]]<-1/length(oak_sectionxx[[i]])
par(fg = "transparent")
# Adding tip labels using this proportional matrix using the previously listed colors
ape::tiplabels(pie = oak_sectionpp, piecol = oak_sectioncols, cex = 0.1)
par(fg = "white")
# Addingthe node labels based on our likely ancestor from the model recapitulation.
nodelabels( node = 1:S$Nnode+Ntip(S),
pie = oak_section.ER$lik.anc, piecol = oak_sectioncols, cex=0.2)
par(fg = "black")
# Providing a legend
legend("bottom", c("Red Oaks (sect. Lobatae)", "White Oaks (sect. Quercus)", "Live Oaks (sect. Virentes)"), pch = 21, pt.bg = c(oak_sectioncols), pt.cex = 2, title = "Oak Section", cex = 1)
# Telling the program we are done creating an image. This results in whatever is plotted being saved
dev.off()
# First, lets isolate the variable we want to graphically model from the original imported data frame
oak_section <- setNames(data$oak_section, rownames(data))
# Rename the levels of the variable
levels(oak_section) <- unique(data$oak_section)
# Recapitulation of the best fit model (see model selection script)
oak_section.ER <- ace(oak_section, S, model = "ER", type = "discrete")
# The model currenlty includes an intermediate state, let's break this intermediate state into the two discrete traits.
oak_section.ER$lik.anc[,1] <- oak_section.ER$lik.anc[,1] + 1/2*(oak_section.ER$lik.anc[,4])
oak_section.ER$lik.anc[,2] <- oak_section.ER$lik.anc[,2] + 1/2*(oak_section.ER$lik.anc[,4])
oak_section.ER$lik.anc <- data.frame(oak_section.ER$lik.anc[,1],oak_section.ER$lik.anc[,2], oak_section.ER$lik.anc[,3])
# Set colors for the pie charts
oak_sectioncols <- c("firebrick1", "grey50", "dodgerblue")
# Now we have the data organized in a way that makes it accessible to the program and we can begin computing the graphical output of the figure. First, I want to save these automatically as vector graphics, so I'll use this function to initiate it.
svg("/home/guerbrown/github_local/biol-4386-course-project-guerbrown/output/inqcophy_traitmodeling_oak_section_guerbrown.svg", width = 20, height = 10)
# Plot the tree in a phylo space with the layout of your choosing
plot.phylo(S, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
# Create a simple data frame with the variables based on the taxa
oak_section_DATA <- setNames(data$oak_section, data$Synergus)
# Split the names of the variable names and list a new object
oak_sectionxx <- strsplit(as.character(oak_section_DATA), split = "+", fixed = T)
# Create a matrix with the variables from the _DATA file by providing lists of occurrence or absence of particular variables for each taxa
oak_sectionpp <- matrix(0, length(oak_section_DATA), 4, dimnames = list(names(oak_section_DATA), c("Lobatae","Quercus", "Virentes", "Quercus+Virentes")))
# Convert this matrix into a matrix of percentages by marking presence as 1 and divide it by the length of the data frame, effectively providign a value of the proportion
for (i in 1:nrow(oak_sectionpp)) oak_sectionpp[i,oak_sectionxx[[i]]]<-1/length(oak_sectionxx[[i]])
par(fg = "transparent")
# Adding tip labels using this proportional matrix using the previously listed colors
ape::tiplabels(pie = oak_sectionpp, piecol = oak_sectioncols, cex = 0.25)
par(fg = "white")
# Addingthe node labels based on our likely ancestor from the model recapitulation.
nodelabels( node = 1:S$Nnode+Ntip(S),
pie = oak_section.ER$lik.anc, piecol = oak_sectioncols, cex=0.4)
par(fg = "black")
# Providing a legend
legend("bottom", c("Red Oaks (sect. Lobatae)", "White Oaks (sect. Quercus)", "Live Oaks (sect. Virentes)"), pch = 21, pt.bg = c(oak_sectioncols), pt.cex = 2, title = "Oak Section", cex = 1)
# Telling the program we are done creating an image. This results in whatever is plotted being saved
dev.off()
