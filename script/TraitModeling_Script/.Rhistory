plot.phylo(S, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
spinesX <- strsplit(setNames(as.character(spines_rate.mat), names(spines_rate.mat)),"+", fixed=TRUE)
pies <- matrix(0, Ntip(S),3,
dimnames=list(S$tip.label,
c("0", "1", "1+0")))
for(i in 1:Ntip(S))
pies[S$tip.label[i],
spinesX[[S$tip.label[i]]]]<-
rep(1/length(spinesX[[S$tip.label[i]]]),
length(spinesX[[S$tip.label[i]]]))
spinescols <- setNames(c("firebrick1", "dodgerblue1", "grey15"),
c("0", "1"))
par(fg="white")
spines <- setNames(data$spines, data$Synergus)
spinesxx <- strsplit(as.character(spines), split = "+", fixed = T)
spinespp <- matrix(0, length(spines), 3, dimnames = list(names(spines), c("0", "1", "1+0")))
for (i in 1:nrow(spinespp)) spinespp[i,spinesxx[[i]]]<-1/length(spinesxx[[i]])
tiplabels(pie = spinespp, piecol = spinescols, cex=0.3)
par(fg="white")
piecol <- spinescols
for(i in 1:ncol(spinesasr)){
spinesnn <- strsplit(colnames(spinesasr)[i],"+", fixed=TRUE)[[1]]
if(length(spinesnn)==1) piecol[i] <- spinescols[spinesnn]
else if(length(spinesnn)==2) piecol[i] <- colorRampPalette(spinescols[spinesnn])(3)[2]
else piecol[i]<-"black"
}
names(piecol)<-colnames(spinesasr)
par(fg="white")
nodelabels(pie = spinesasr, piecol = spinescols,cex=0.40)
par(fg="black")
legend("bottom", c("No Spines", "Spines", "No Preference"), pch = 21, pt.bg = c("firebrick1", "dodgerblue1", "grey15"), pt.cex = 2, cex = 1)
smap.spinestrees <- make.simmap(spines.ER$data,
Q = as.Qmatrix(spines.ER), pi = spines.ER$pi,
nsim = 100)
smap.spinestrees <- make.simmap(S, spines.ER$data,
Q = as.Qmatrix(spines.ER), pi = spines.ER$pi,
nsim = 100)
plot.phylo(smap.spinestrees, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
plot(smap.spinestrees, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
plot(smap.spinestrees, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2)
plot(smap.spinestrees, type = "fan", cex = 1.1, lwd = 2)
plot(smap.spinestrees, type = "fan", lwd = 2)
knitr::opts_chunk$set(echo = TRUE)
spines <- setNames(data$spines, rownames(data))
levels(spines) <- unique(data$spines)
spines.ER <- fitpolyMk(S, spines, model = "ER")
library(ape)
library(phytools)
library(geiger)
library(corHMM)
setwd("//wsl.localhost/Ubuntu/home/guerbrown/github_local/biol-4386-course-project-guerbrown/data/TraitModeling")
tree <- "//wsl.localhost/Ubuntu/home/guerbrown/github_local/biol-4386-course-project-guerbrown/data/TraitModeling/inqcophy_traitmodeling_SynTree_guerbrown.nex"
traits <- "//wsl.localhost/Ubuntu/home/guerbrown/github_local/biol-4386-course-project-guerbrown/data/TraitModeling/inqcophy_traitmodeling_TraitData_guerbrown.csv"
# Import
S <- readNexus(tree)
# Rooting the phylogeny based on a version of the tree with an outgroup and plotting
root.phylo(S, 28, resolve.root = T)
# Importing the .csv file with our traits
data <- read.csv(traits, row.names = 1)
# First, lets isolate the variable we want to graphically model from the original imported data frame
oak_section <- setNames(data$oak_section, rownames(data))
# Rename the levels of the variable
levels(oak_section) <- unique(data$oak_section)
# Recapitulation of the best fit model (see model selection script)
oak_section.ER <- fitpolyMk(S, oak_section, model = "ER")
# pull states off the fitted model object
oak_sectionxx <- apply(oak_section.ER$data,1,
function(x,ss) ss[which(x==1)],
ss=colnames(oak_section.ER$data))
# corHMM does not like to work with + so let's replace those with /
oak_sectionxx <- gsub("+","/", oak_sectionxx, fixed=TRUE)
# build corHMM data frame
oak_section.data <- data.frame(Genus_sp = names(oak_sectionxx), oak_section = oak_sectionxx)
# Pull out model design matrix from the fitted object
oak_section_rate.mat <- oak_section.ER$index.matrix
# Set any values of 0 in the design matrix to NA
oak_section_rate.mat[oak_section_rate.mat==0] <- NA
# Replace previous / with + in the new data design matrix
colnames(oak_section_rate.mat) <- rownames(oak_section_rate.mat) <- gsub("+","/", colnames(oak_section_rate.mat), fixed=TRUE)
# Order these from highest to lowest and name it something different that will allow us to transition the design matrix into something corHMM can utilize
oak_sectionind <- order(colnames(oak_section_rate.mat))
oak_section_rate.mat <- oak_section_rate.mat[oak_sectionind, oak_sectionind]
# Ancestral States (this part of the analysis is compiling everything we've extracted that has importance)
oak_section_fit.marginal <- corHMM(S, oak_section.data,
rate.mat = oak_section_rate.mat,
node.states = "marginal",
rate.cat = 1, p = oak_section.ER$rates,
root.p = oak_section.ER$pi)
# Marginal states are stores in $states. Extract this and ensure the model is consistent
oak_sectionasr <- oak_section_fit.marginal$states
colnames(oak_sectionasr) <- colnames(oak_section_rate.mat)
colnames(oak_sectionasr) <- gsub("/","+", colnames(oak_sectionasr))
# Prepare a graphical output for the phylogeny we are about to create
#svg("/home/guerbrown/github_local/biol-4386-course-project-guerbrown/output/inqcophy_traitmodeling_oak_section_guerbrown.svg", width = 20, height = 10)
# Plot the tree in a phylo space with the layout of your choosing
plot.phylo(S, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
# Split the names of the trait so that the data frame recognizes traits with + as a combination of two or more traits
oak_sectionX <- strsplit(setNames(as.character(oak_section_rate.mat), names(oak_section_rate.mat)),"+", fixed=TRUE)
# Create pie charts of the traits you wish to graph on the tip labels. If you do not wish to represent a polymorphic trait as a discrete trait at tips, please run this **without** the code above.
pies <- matrix(0, Ntip(S),3,
dimnames=list(S$tip.label,
c("1", "2", "3")))
# Add data to the values for our pie charts
for(i in 1:Ntip(S))
pies[S$tip.label[i],
oak_sectionX[[S$tip.label[i]]]]<-
rep(1/length(oak_sectionX[[S$tip.label[i]]]),
length(oak_sectionX[[S$tip.label[i]]]))
# Provide a set of color variables that we can use later
oak_sectioncols <- setNames(c("firebrick1", "dodgerblue1", "grey15"),
c("Quercus", "Lobatae","Virentes"))
par(fg="white")
# Create a matrix of the trait and provide the names for its dimensions.
oak_sectionpp <- matrix(0, length(oak_section), 4, dimnames = list(names(oak_section), c("Lobatae","Quercus", "Virentes", "Quercus+Virentes")))
# Add data to this matrix. This line of code is a BEAST to understand. In short, it is adding values of the pp matrix from the xx data frame then dividing it so that we have proportional values based on a scale of 100. I say it is so complex because the spacing of the code is dense and there are a lot of specifiers one may not normally encounter. It is actually quite brilliant but I owe this to L. Revell, whose blog I adapted it from.
for (i in 1:nrow(oak_sectionpp)) oak_sectionpp[i,oak_sectionxx[[i]]]<-1/length(oak_sectionxx[[i]])
spines <- setNames(data$spines, rownames(data))
levels(spines) <- unique(data$spines)
spines.ER <- fitpolyMk(S, spines, model = "ER")
spinesxx <- apply(spines.ER$data,1,
function(x,ss) ss[which(x==1)],
ss=colnames(spines.ER$data))
spinesxx <- gsub("+","/", spinesxx, fixed=TRUE)
spines.data <- data.frame(Genus_sp = names(spinesxx), spines = spinesxx)
spines_rate.mat <- spines.ER$index.matrix
spines_rate.mat[spines_rate.mat==0] <- NA
colnames(spines_rate.mat) <- rownames(spines_rate.mat) <- gsub("+","/", colnames(spines_rate.mat), fixed=TRUE)
spinesind <- order(colnames(spines_rate.mat))
spines_rate.mat <- spines_rate.mat[spinesind, spinesind]
spines_fit.marginal <- corHMM(S, spines.data,
rate.mat = spines_rate.mat,
node.states = "marginal",
rate.cat = 1, p = spines.ER$rates,
root.p = spines.ER$pi)
spinesasr <- spines_fit.marginal$states
colnames(spinesasr) <- colnames(spines_rate.mat)
colnames(spinesasr) <- gsub("/","+", colnames(spinesasr))
#svg("/home/guerbrown/github_local/biol-4386-course-project-guerbrown/output/inqcophy_traitmodeling_spines_guerbrown.svg", width = 20, height = 10)
spinespp <- matrix(0, length(spines), 3, dimnames = list(names(spines), c("0", "1", "1+0")))
plot.phylo(S, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
spinesX <- strsplit(setNames(as.character(spines_rate.mat), names(spines_rate.mat)),"+", fixed=TRUE)
pies <- matrix(0, Ntip(S),2,
dimnames=list(S$tip.label,
c("0", "1")))
for(i in 1:Ntip(S))
pies[S$tip.label[i],
spinesX[[S$tip.label[i]]]]<-
rep(1/length(spinesX[[S$tip.label[i]]]),
length(spinesX[[S$tip.label[i]]]))
spinescols <- setNames(c("firebrick1", "dodgerblue1"),
c("0", "1"))
par(fg="white")
spines <- setNames(data$spines, data$Synergus)
spinesxx <- strsplit(as.character(spines), split = "+", fixed = T)
spinespp <- matrix(0, length(spines), 3, dimnames = list(names(spines), c("0", "1", "1+0")))
for (i in 1:nrow(spinespp)) spinespp[i,spinesxx[[i]]]<-1/length(spinesxx[[i]])
tiplabels(pie = spinespp, piecol = spinescols, cex=0.3)
par(fg="white")
piecol <- spinescols
for(i in 1:ncol(spinesasr)){
spinesnn <- strsplit(colnames(spinesasr)[i],"+", fixed=TRUE)[[1]]
if(length(spinesnn)==1) piecol[i] <- spinescols[spinesnn]
else if(length(spinesnn)==2) piecol[i] <- colorRampPalette(spinescols[spinesnn])(3)[2]
else piecol[i]<-"black"
}
names(piecol)<-colnames(spinesasr)
par(fg="white")
nodelabels(pie = spinesasr, piecol = spinescols,cex=0.40)
par(fg="black")
legend("bottom", c("No Spines", "Spines"), pch = 21, pt.bg = c("firebrick1", "dodgerblue1"), pt.cex = 2, cex = 1)
smap.trees<-make.simmap(lizard.tree,ordered.transient$data,
Q=as.Qmatrix(ordered.transient),pi=ordered.transient$pi,
nsim=100)
smap.trees<-make.simmap(lizard.tree,ordered.transient$data,
Q=as.Qmatrix(ordered.transient),pi=ordered.transient$pi,
nsim=100)
spines <- setNames(data$spines, rownames(data))
levels(spines) <- unique(data$spines)
spines.ER <- fitpolyMk(S, spines, model = "ER")
spinesxx <- apply(spines.ER$data,1,
function(x,ss) ss[which(x==1)],
ss=colnames(spines.ER$data))
spinesxx <- gsub("+","/", spinesxx, fixed=TRUE)
spines.data <- data.frame(Genus_sp = names(spinesxx), spines = spinesxx)
spines_rate.mat <- spines.ER$index.matrix
spines_rate.mat[spines_rate.mat==0] <- NA
colnames(spines_rate.mat) <- rownames(spines_rate.mat) <- gsub("+","/", colnames(spines_rate.mat), fixed=TRUE)
spinesind <- order(colnames(spines_rate.mat))
spines_rate.mat <- spines_rate.mat[spinesind, spinesind]
spines_fit.marginal <- corHMM(S, spines.data,
rate.mat = spines_rate.mat,
node.states = "marginal",
rate.cat = 1, p = spines.ER$rates,
root.p = spines.ER$pi)
spinesasr <- spines_fit.marginal$states
colnames(spinesasr) <- colnames(spines_rate.mat)
colnames(spinesasr) <- gsub("/","+", colnames(spinesasr))
#svg("/home/guerbrown/github_local/biol-4386-course-project-guerbrown/output/inqcophy_traitmodeling_spines_guerbrown.svg", width = 20, height = 10)
spinespp <- matrix(0, length(spines), 3, dimnames = list(names(spines), c("0", "1", "1+0")))
plot.phylo(S, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
spinesX <- strsplit(setNames(as.character(spines_rate.mat), names(spines_rate.mat)),"+", fixed=TRUE)
pies <- matrix(0, Ntip(S),2,
dimnames=list(S$tip.label,
c("0", "1")))
for(i in 1:Ntip(S))
pies[S$tip.label[i],
spinesX[[S$tip.label[i]]]]<-
rep(1/length(spinesX[[S$tip.label[i]]]),
length(spinesX[[S$tip.label[i]]]))
spinescols <- setNames(c("firebrick1", "dodgerblue1"),
c("0", "1"))
par(fg="white")
spines <- setNames(data$spines, data$Synergus)
spinesxx <- strsplit(as.character(spines), split = "+", fixed = T)
spinespp <- matrix(0, length(spines), 3, dimnames = list(names(spines), c("0", "1", "1+0")))
for (i in 1:nrow(spinespp)) spinespp[i,spinesxx[[i]]]<-1/length(spinesxx[[i]])
tiplabels(pie = spinespp, piecol = spinescols, cex=0.3)
par(fg="white")
piecol <- spinescols
for(i in 1:ncol(spinesasr)){
spinesnn <- strsplit(colnames(spinesasr)[i],"+", fixed=TRUE)[[1]]
if(length(spinesnn)==1) piecol[i] <- spinescols[spinesnn]
else if(length(spinesnn)==2) piecol[i] <- colorRampPalette(spinescols[spinesnn])(3)[2]
else piecol[i]<-"black"
}
names(piecol)<-colnames(spinesasr)
par(fg="white")
nodelabels(pie = spinesasr, piecol = spinescols,cex=0.40)
par(fg="black")
legend("bottom", c("No Spines", "Spines"), pch = 21, pt.bg = c("firebrick1", "dodgerblue1"), pt.cex = 2, cex = 1)
smap.trees<-make.simmap(S, spines.ER$data,
Q=as.Qmatrix(spines.ER),pi=spines.ER$pi,
nsim=100)
smap.spinestrees <- make.simmap(S, spines.ER$data,
Q = as.Qmatrix(spines.ER), pi = spines.ER$pi,
nsim = 100)
par(mfrow = c(10,10))
plot(smap.spinestrees, type = "fan", lwd = 2)
par(fg="transparent")
plot(summary(smap.spinestrees),colors=piecol,type="fan",ftype="off",
lwd=1,cex=c(0.5,0.3))
par(fg="black")
legend(x="topleft",legend=colnames(asr),
pt.cex=1.8,pch=16,cex=0.8,col=piecol,
bty="n")
par(fg="transparent")
plot(summary(smap.spinestrees),colors=piecol,type="fan",ftype="off",
lwd=1,cex=c(0.5,0.3))
par(fg="black")
legend(x="topleft",legend=colnames(asr),
pt.cex=1.8,pch=16,cex=0.8,col=piecol,
bty="n")
legend(x="topleft",legend=colnames(spinesasr),
pt.cex=1.8,pch=16,cex=0.8,col=piecol,
bty="n")
par(fg="transparent")
plot(summary(smap.spinestrees),colors=piecol,type="fan",ftype="off",
lwd=1,cex=c(0.5,0.3))
par(fg="black")
legend(x="topleft",legend=colnames(spinesasr),
pt.cex=1.8,pch=16,cex=0.8,col=piecol,
bty="n")
plot.phylo(summary(smap.spinestrees, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
par(fg="transparent")
par(fg="transparent")
plot.phylo(summary(smap.spinestrees, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100))
par(fg="black")
legend(x="topleft",legend=colnames(spinesasr),
pt.cex=1.8,pch=16,cex=0.8,col=piecol,
bty="n")
plot.phylo(summary(smap.spinestrees, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100))
plot.phylo(summary(smap.spinestrees), type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
plot.phylo(summary(smap.spinestrees), type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
plot.phylo(smap.spinestrees, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
tree <- map.to.singleton(smap.spinestrees)
View(smap.spinestrees)
spines <- setNames(data$spines, rownames(data))
levels(spines) <- unique(data$spines)
spines.ER <- fitpolyMk(S, spines, model = "ER")
spinesxx <- apply(spines.ER$data,1,
function(x,ss) ss[which(x==1)],
ss=colnames(spines.ER$data))
spinesxx <- gsub("+","/", spinesxx, fixed=TRUE)
spines.data <- data.frame(Genus_sp = names(spinesxx), spines = spinesxx)
spines_rate.mat <- spines.ER$index.matrix
spines_rate.mat[spines_rate.mat==0] <- NA
colnames(spines_rate.mat) <- rownames(spines_rate.mat) <- gsub("+","/", colnames(spines_rate.mat), fixed=TRUE)
spinesind <- order(colnames(spines_rate.mat))
spines_rate.mat <- spines_rate.mat[spinesind, spinesind]
spines_fit.marginal <- corHMM(S, spines.data,
rate.mat = spines_rate.mat,
node.states = "marginal",
rate.cat = 1, p = spines.ER$rates,
root.p = spines.ER$pi)
spinesasr <- spines_fit.marginal$states
colnames(spinesasr) <- colnames(spines_rate.mat)
colnames(spinesasr) <- gsub("/","+", colnames(spinesasr))
#svg("/home/guerbrown/github_local/biol-4386-course-project-guerbrown/output/inqcophy_traitmodeling_spines_guerbrown.svg", width = 20, height = 10)
spinespp <- matrix(0, length(spines), 3, dimnames = list(names(spines), c("0", "1", "1+0")))
plot.phylo(S, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
spinesX <- strsplit(setNames(as.character(spines_rate.mat), names(spines_rate.mat)),"+", fixed=TRUE)
pies <- matrix(0, Ntip(S),2,
dimnames=list(S$tip.label,
c("0", "1")))
for(i in 1:Ntip(S))
pies[S$tip.label[i],
spinesX[[S$tip.label[i]]]]<-
rep(1/length(spinesX[[S$tip.label[i]]]),
length(spinesX[[S$tip.label[i]]]))
spinescols <- setNames(c("firebrick1", "dodgerblue1"),
c("0", "1"))
par(fg="white")
spines <- setNames(data$spines, data$Synergus)
spinesxx <- strsplit(as.character(spines), split = "+", fixed = T)
spinespp <- matrix(0, length(spines), 3, dimnames = list(names(spines), c("0", "1", "1+0")))
for (i in 1:nrow(spinespp)) spinespp[i,spinesxx[[i]]]<-1/length(spinesxx[[i]])
tiplabels(pie = spinespp, piecol = spinescols, cex=0.3)
par(fg="white")
piecol <- spinescols
for(i in 1:ncol(spinesasr)){
spinesnn <- strsplit(colnames(spinesasr)[i],"+", fixed=TRUE)[[1]]
if(length(spinesnn)==1) piecol[i] <- spinescols[spinesnn]
else if(length(spinesnn)==2) piecol[i] <- colorRampPalette(spinescols[spinesnn])(3)[2]
else piecol[i]<-"black"
}
names(piecol)<-colnames(spinesasr)
par(fg="white")
nodelabels(pie = spinesasr, piecol = spinescols,cex=0.40)
par(fg="black")
legend("bottom", c("No Spines", "Spines"), pch = 21, pt.bg = c("firebrick1", "dodgerblue1"), pt.cex = 2, cex = 1)
smap.trees<-make.simmap(S, spines.ER$data,
Q=as.Qmatrix(spines.ER),pi=spines.ER$pi,
nsim=100)
smap.spinestrees <- make.simmap(S, spines.ER$data,
Q = as.Qmatrix(spines.ER), pi = spines.ER$pi,
nsim = 100)
par(mfrow = c(10,10))
plot(smap.spinestrees, type = "fan", lwd = 2)
tree <- summary(smap.spinestrees)
par(fg="transparent")
tree <- map.to.singleton(smap.spinestrees)
tree <- summary(smap.spinestrees)
plot.phylo(tree), type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
plot(tree)
plot.phylo(tree, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
tree
plotSimmap(tree, colors = cols, fsize = 1.1, type = "fan")
plotSimmap(smap.spinestrees, colors = cols, fsize = 1.1, type = "fan")
spinescols <- setNames(c("firebrick1", "dodgerblue1", "grey15"),
c("0", "1"))
knitr::opts_chunk$set(echo = TRUE)
library(ape)
library(phytools)
library(geiger)
library(corHMM)
setwd("//wsl.localhost/Ubuntu/home/guerbrown/github_local/biol-4386-course-project-guerbrown/data/TraitModeling")
tree <- "//wsl.localhost/Ubuntu/home/guerbrown/github_local/biol-4386-course-project-guerbrown/data/TraitModeling/inqcophy_traitmodeling_SynTree_guerbrown.nex"
traits <- "//wsl.localhost/Ubuntu/home/guerbrown/github_local/biol-4386-course-project-guerbrown/data/TraitModeling/inqcophy_traitmodeling_TraitData_guerbrown.csv"
# Import
S <- readNexus(tree)
# Rooting the phylogeny based on a version of the tree with an outgroup and plotting
root.phylo(S, 28, resolve.root = T)
# Importing the .csv file with our traits
data <- read.csv(traits, row.names = 1)
# First, lets isolate the variable we want to graphically model from the original imported data frame
oak_section <- setNames(data$oak_section, rownames(data))
# Rename the levels of the variable
levels(oak_section) <- unique(data$oak_section)
# Recapitulation of the best fit model (see model selection script)
oak_section.ER <- fitpolyMk(S, oak_section, model = "ER")
# pull states off the fitted model object
oak_sectionxx <- apply(oak_section.ER$data,1,
function(x,ss) ss[which(x==1)],
ss=colnames(oak_section.ER$data))
# corHMM does not like to work with + so let's replace those with /
oak_sectionxx <- gsub("+","/", oak_sectionxx, fixed=TRUE)
# build corHMM data frame
oak_section.data <- data.frame(Genus_sp = names(oak_sectionxx), oak_section = oak_sectionxx)
# Pull out model design matrix from the fitted object
oak_section_rate.mat <- oak_section.ER$index.matrix
# Set any values of 0 in the design matrix to NA
oak_section_rate.mat[oak_section_rate.mat==0] <- NA
# Replace previous / with + in the new data design matrix
colnames(oak_section_rate.mat) <- rownames(oak_section_rate.mat) <- gsub("+","/", colnames(oak_section_rate.mat), fixed=TRUE)
# Order these from highest to lowest and name it something different that will allow us to transition the design matrix into something corHMM can utilize
oak_sectionind <- order(colnames(oak_section_rate.mat))
oak_section_rate.mat <- oak_section_rate.mat[oak_sectionind, oak_sectionind]
# Ancestral States (this part of the analysis is compiling everything we've extracted that has importance)
oak_section_fit.marginal <- corHMM(S, oak_section.data,
rate.mat = oak_section_rate.mat,
node.states = "marginal",
rate.cat = 1, p = oak_section.ER$rates,
root.p = oak_section.ER$pi)
# Marginal states are stores in $states. Extract this and ensure the model is consistent
oak_sectionasr <- oak_section_fit.marginal$states
colnames(oak_sectionasr) <- colnames(oak_section_rate.mat)
colnames(oak_sectionasr) <- gsub("/","+", colnames(oak_sectionasr))
# Prepare a graphical output for the phylogeny we are about to create
#svg("/home/guerbrown/github_local/biol-4386-course-project-guerbrown/output/inqcophy_traitmodeling_oak_section_guerbrown.svg", width = 20, height = 10)
# Plot the tree in a phylo space with the layout of your choosing
plot.phylo(S, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
# Split the names of the trait so that the data frame recognizes traits with + as a combination of two or more traits
oak_sectionX <- strsplit(setNames(as.character(oak_section_rate.mat), names(oak_section_rate.mat)),"+", fixed=TRUE)
# Create pie charts of the traits you wish to graph on the tip labels. If you do not wish to represent a polymorphic trait as a discrete trait at tips, please run this **without** the code above.
pies <- matrix(0, Ntip(S),3,
dimnames=list(S$tip.label,
c("1", "2", "3")))
# Add data to the values for our pie charts
for(i in 1:Ntip(S))
pies[S$tip.label[i],
oak_sectionX[[S$tip.label[i]]]]<-
rep(1/length(oak_sectionX[[S$tip.label[i]]]),
length(oak_sectionX[[S$tip.label[i]]]))
# Provide a set of color variables that we can use later
oak_sectioncols <- setNames(c("firebrick1", "dodgerblue1", "grey15"),
c("Quercus", "Lobatae","Virentes"))
par(fg="white")
# Create a matrix of the trait and provide the names for its dimensions.
oak_sectionpp <- matrix(0, length(oak_section), 4, dimnames = list(names(oak_section), c("Lobatae","Quercus", "Virentes", "Quercus+Virentes")))
# Add data to this matrix. This line of code is a BEAST to understand. In short, it is adding values of the pp matrix from the xx data frame then dividing it so that we have proportional values based on a scale of 100. I say it is so complex because the spacing of the code is dense and there are a lot of specifiers one may not normally encounter. It is actually quite brilliant but I owe this to L. Revell, whose blog I adapted it from.
for (i in 1:nrow(oak_sectionpp)) oak_sectionpp[i,oak_sectionxx[[i]]]<-1/length(oak_sectionxx[[i]])
smap.trees<-make.simmap(S, spines.ER$data,
Q=as.Qmatrix(spines.ER),pi=spines.ER$pi,
nsim=100)
smap.spinestrees <- make.simmap(S, spines.ER$data,
Q = as.Qmatrix(spines.ER), pi = spines.ER$pi,
nsim = 100)
par(mfrow = c(10,10))
plot(smap.spinestrees, type = "fan", lwd = 2)
tree <- summary(smap.spinestrees)
par(fg="transparent")
tree <- map.to.singleton(smap.spinestrees)
plot(summary(smap.spinestrees), colors = spinescols)
plot(summary(smap.spinestrees), colors = spinescols, type = "fan")
plot.phylo(summary(smap.spinestrees))
ape::plot.multiPhylo(smap.spinestrees)
ape::plot.phylo(smap.spinestrees)
tree <- as.phylo(summary(smap.spinestrees))
View(smap.spinestrees)
summary(smap.spinestrees)
plot(tree, type = "fan", ftype = "i", lwd = 2, part = 0.5)
plot.phylo(tree, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
class(tree)
spines <- setNames(data$spines, rownames(data))
levels(spines) <- unique(data$spines)
spines.ER <- fitpolyMk(S, spines, model = "ER")
spinesxx <- apply(spines.ER$data,1,
function(x,ss) ss[which(x==1)],
ss=colnames(spines.ER$data))
spinesxx <- gsub("+","/", spinesxx, fixed=TRUE)
spines.data <- data.frame(Genus_sp = names(spinesxx), spines = spinesxx)
spines_rate.mat <- spines.ER$index.matrix
spines_rate.mat[spines_rate.mat==0] <- NA
colnames(spines_rate.mat) <- rownames(spines_rate.mat) <- gsub("+","/", colnames(spines_rate.mat), fixed=TRUE)
spinesind <- order(colnames(spines_rate.mat))
spines_rate.mat <- spines_rate.mat[spinesind, spinesind]
spines_fit.marginal <- corHMM(S, spines.data,
rate.mat = spines_rate.mat,
node.states = "marginal",
rate.cat = 1, p = spines.ER$rates,
root.p = spines.ER$pi)
spinesasr <- spines_fit.marginal$states
colnames(spinesasr) <- colnames(spines_rate.mat)
colnames(spinesasr) <- gsub("/","+", colnames(spinesasr))
#svg("/home/guerbrown/github_local/biol-4386-course-project-guerbrown/output/inqcophy_traitmodeling_spines_guerbrown.svg", width = 20, height = 10)
spinespp <- matrix(0, length(spines), 3, dimnames = list(names(spines), c("0", "1", "1+0")))
plot.phylo(S, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
spinesX <- strsplit(setNames(as.character(spines_rate.mat), names(spines_rate.mat)),"+", fixed=TRUE)
pies <- matrix(0, Ntip(S),2,
dimnames=list(S$tip.label,
c("0", "1")))
for(i in 1:Ntip(S))
pies[S$tip.label[i],
spinesX[[S$tip.label[i]]]]<-
rep(1/length(spinesX[[S$tip.label[i]]]),
length(spinesX[[S$tip.label[i]]]))
spinescols <- setNames(c("firebrick1", "dodgerblue1", "grey15"),
c("0", "1", "1+0"))
par(fg="white")
spines <- setNames(data$spines, data$Synergus)
spinesxx <- strsplit(as.character(spines), split = "+", fixed = T)
spinespp <- matrix(0, length(spines), 3, dimnames = list(names(spines), c("0", "1", "1+0")))
for (i in 1:nrow(spinespp)) spinespp[i,spinesxx[[i]]]<-1/length(spinesxx[[i]])
tiplabels(pie = spinespp, piecol = spinescols, cex=0.3)
par(fg="white")
piecol <- spinescols
for(i in 1:ncol(spinesasr)){
spinesnn <- strsplit(colnames(spinesasr)[i],"+", fixed=TRUE)[[1]]
if(length(spinesnn)==1) piecol[i] <- spinescols[spinesnn]
else if(length(spinesnn)==2) piecol[i] <- colorRampPalette(spinescols[spinesnn])(3)[2]
else piecol[i]<-"black"
}
names(piecol)<-colnames(spinesasr)
par(fg="white")
nodelabels(pie = spinesasr, piecol = spinescols,cex=0.40)
par(fg="black")
legend("bottom", c("No Spines", "Spines"), pch = 21, pt.bg = c("firebrick1", "dodgerblue1"), pt.cex = 2, cex = 1)
smap.trees<-make.simmap(S, spines.ER$data,
Q=as.Qmatrix(spines.ER),pi=spines.ER$pi,
nsim=100)
smap.spinestrees <- make.simmap(S, spines.ER$data,
Q = as.Qmatrix(spines.ER), pi = spines.ER$pi,
nsim = 100)
class(S)
describe.simmap(tree)
describe.simmap(smap.spinestrees)
plot(tree, ftype = "i", type = "fan", fsize = 0.7, offset = 5, part = 1, outline = T, lwd = 3.5, align.tip.lable = T)
plot(tree, ftype = "i", type = "fan", fsize = 0.7, offset = 5, part = 1, outline = T, lwd = 3.5, align.tip.lable = F)
plot(tree, ftype = "i", type = "fan", fsize = 0.7, offset = 5, part = 0.5, outline = T, lwd = 3.5, align.tip.lable = T)
plotSimmap(tree, ftype = "i", type = "fan", fsize = 0.7, offset = 5, part = 0.5, outline = T, lwd = 3.5, align.tip.lable = T)
read.simmap(smap.spinestrees)
read.simmap(smap.spinestrees, format = "nexus")
