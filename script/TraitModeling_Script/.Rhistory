dev.off()
fleshy <- setNames(data$fleshy, rownames(data))
levels(fleshy) <- unique(data$fleshy)
fleshy.ER <- fitpolyMk(S, fleshy, model = "ER")
fleshyxx <- apply(fleshy.ER$data,1,
function(x,ss) ss[which(x==1)],
ss=colnames(fleshy.ER$data))
fleshyxx <- gsub("+","/", fleshyxx, fixed=TRUE)
fleshy.data <- data.frame(Genus_sp = names(fleshyxx), fleshy = fleshyxx)
fleshy_rate.mat <- fleshy.ER$index.matrix
fleshy_rate.mat[fleshy_rate.mat==0] <- NA
colnames(fleshy_rate.mat) <- rownames(fleshy_rate.mat) <- gsub("+","/", colnames(fleshy_rate.mat), fixed=TRUE)
fleshyind <- order(colnames(fleshy_rate.mat))
fleshy_rate.mat <- fleshy_rate.mat[fleshyind, fleshyind]
fleshy_fit.marginal <- corHMM(S, fleshy.data,
rate.mat = fleshy_rate.mat,
node.states = "marginal",
rate.cat = 1, p = fleshy.ER$rates,
root.p = fleshy.ER$pi)
fleshyasr <- fleshy_fit.marginal$states
colnames(fleshyasr) <- colnames(fleshy_rate.mat)
colnames(fleshyasr) <- gsub("/","+", colnames(fleshyasr))
svg("/home/guerbrown/github_local/biol-4386-course-project-guerbrown/output/inqcophy_traitmodeling_fleshy_guerbrown.svg", width = 20, height = 10)
fleshypp <- matrix(0, length(fleshy), 3, dimnames = list(names(fleshy), c("0", "1", "1+0")))
plot.phylo(S, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
fleshyX <- strsplit(setNames(as.character(fleshy_rate.mat), names(fleshy_rate.mat)),"+", fixed=TRUE)
pies <- matrix(0, Ntip(S),2,
dimnames=list(S$tip.label,
c("0", "1")))
for(i in 1:Ntip(S))
pies[S$tip.label[i],
fleshyX[[S$tip.label[i]]]]<-
rep(1/length(fleshyX[[S$tip.label[i]]]),
length(fleshyX[[S$tip.label[i]]]))
fleshycols <- setNames(c("firebrick1", "dodgerblue1", "grey15"),
c("0", "1"))
par(fg="white")
fleshy <- setNames(data$fleshy, data$Synergus)
fleshyxx <- strsplit(as.character(fleshy), split = "+", fixed = T)
fleshypp <- matrix(0, length(fleshy), 3, dimnames = list(names(fleshy), c("0", "1", "1+0")))
for (i in 1:nrow(fleshypp)) fleshypp[i,fleshyxx[[i]]]<-1/length(fleshyxx[[i]])
tiplabels(pie = fleshypp, piecol = fleshycols, cex=0.3)
par(fg="white")
piecol <- fleshycols
for(i in 1:ncol(fleshyasr)){
fleshynn <- strsplit(colnames(fleshyasr)[i],"+", fixed=TRUE)[[1]]
if(length(fleshynn)==1) piecol[i] <- fleshycols[fleshynn]
else if(length(fleshynn)==2) piecol[i] <- colorRampPalette(fleshycols[fleshynn])(3)[2]
else piecol[i]<-"black"
}
names(piecol)<-colnames(fleshyasr)
par(fg="white")
nodelabels(pie = fleshyasr, piecol = fleshycols,cex=0.40)
par(fg="black")
legend("bottom", c("Not Fleshy", "Fleshy", "Both"), pch = 21, pt.bg = c("firebrick1", "dodgerblue1", "grey15"), pt.cex = 2, cex = 1)
dev.off()
season <- setNames(data$season, rownames(data))
levels(season) <- unique(data$season)
season.ER <- fitpolyMk(S, season, model = "ER")
seasonxx <- apply(season.ER$data,1,
function(x,ss) ss[which(x==1)],
ss=colnames(season.ER$data))
seasonxx <- gsub("+","/", seasonxx, fixed=TRUE)
season.data <- data.frame(Genus_sp = names(seasonxx), season = seasonxx)
season_rate.mat <- season.ER$index.matrix
season_rate.mat[season_rate.mat==0] <- NA
colnames(season_rate.mat) <- rownames(season_rate.mat) <- gsub("+","/", colnames(season_rate.mat), fixed=TRUE)
seasonind <- order(colnames(season_rate.mat))
season_rate.mat <- season_rate.mat[seasonind, seasonind]
season_fit.marginal <- corHMM(S, season.data,
rate.mat = season_rate.mat,
node.states = "marginal",
rate.cat = 1, p = season.ER$rates,
root.p = season.ER$pi)
seasonasr <- season_fit.marginal$states
colnames(seasonasr) <- colnames(season_rate.mat)
colnames(seasonasr) <- gsub("/","+", colnames(seasonasr))
svg("/home/guerbrown/github_local/biol-4386-course-project-guerbrown/output/inqcophy_traitmodeling_season_guerbrown.svg", width = 20, height = 10)
seasonpp <- matrix(0, length(season), 3, dimnames = list(names(season), c("3", "2", "2+3")))
plot.phylo(S, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
seasonX <- strsplit(setNames(as.character(season_rate.mat), names(season_rate.mat)),"+", fixed=TRUE)
pies <- matrix(0, Ntip(S),3,
dimnames=list(S$tip.label,
c("3", "2", "2+3")))
for(i in 1:Ntip(S))
pies[S$tip.label[i],
seasonX[[S$tip.label[i]]]]<-
rep(1/length(seasonX[[S$tip.label[i]]]),
length(seasonX[[S$tip.label[i]]]))
seasoncols <- setNames(c("firebrick1", "dodgerblue1", "grey15"),
c("0", "1"))
par(fg="white")
season <- setNames(data$season, data$Synergus)
seasonxx <- strsplit(as.character(season), split = "+", fixed = T)
seasonpp <- matrix(0, length(season), 3, dimnames = list(names(season), c("3", "2", "2+3")))
for (i in 1:nrow(seasonpp)) seasonpp[i,seasonxx[[i]]]<-1/length(seasonxx[[i]])
tiplabels(pie = seasonpp, piecol = seasoncols, cex=0.3)
par(fg="white")
piecol <- seasoncols
for(i in 1:ncol(seasonasr)){
seasonnn <- strsplit(colnames(seasonasr)[i],"+", fixed=TRUE)[[1]]
if(length(seasonnn)==1) piecol[i] <- seasoncols[seasonnn]
else if(length(seasonnn)==2) piecol[i] <- colorRampPalette(seasoncols[seasonnn])(3)[2]
else piecol[i]<-"black"
}
names(piecol)<-colnames(seasonasr)
par(fg="white")
nodelabels(pie = seasonasr, piecol = seasoncols,cex=0.40)
par(fg="black")
legend("bottom", c("Fall", "Summer", "Fall+Summer"), pch = 21, pt.bg = c("firebrick1", "dodgerblue1", "grey15"), pt.cex = 2, title = "Season", cex = 1)
dev.off()
location <- setNames(data$location, rownames(data))
levels(location) <- unique(data$location)
location.ER <- fitpolyMk(S, location, model = "ER")
locationxx <- apply(location.ER$data,1,
function(x,ss) ss[which(x==1)],
ss=colnames(location.ER$data))
locationxx <- gsub("+","/", locationxx, fixed=TRUE)
location.data <- data.frame(Genus_sp = names(locationxx), location = locationxx)
location_rate.mat <- location.ER$index.matrix
location_rate.mat[location_rate.mat==0] <- NA
colnames(location_rate.mat) <- rownames(location_rate.mat) <- gsub("+","/", colnames(location_rate.mat), fixed=TRUE)
locationind <- order(colnames(location_rate.mat))
location_rate.mat <- location_rate.mat[locationind, locationind]
location_fit.marginal <- corHMM(S, location.data,
rate.mat = location_rate.mat,
node.states = "marginal",
rate.cat = 1, p = location.ER$rates,
root.p = location.ER$pi)
locationasr <- location_fit.marginal$states
colnames(locationasr) <- colnames(location_rate.mat)
colnames(locationasr) <- gsub("/","+", colnames(locationasr))
#svg("/home/guerbrown/github_local/biol-4386-course-project-guerbrown/output/inqcophy_traitmodeling_location_guerbrown.svg", width = 20, height = 10)
locationpp <- matrix(0, length(location), 7, dimnames = list(names(location), c("leaf", "stem", "stem+leaf", "petiole+stem", "acorn", "bud", "bud+leaf+acorn")))
plot.phylo(S, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
locationX <- strsplit(setNames(as.character(location_rate.mat), names(location_rate.mat)),"+", fixed=TRUE)
pies <- matrix(0, Ntip(S),7,
dimnames=list(S$tip.label,
c("leaf", "stem", "stem+leaf", "petiole+stem", "acorn", "bud", "bud+leaf+acorn")))
for(i in 1:Ntip(S))
pies[S$tip.label[i],
locationX[[S$tip.label[i]]]]<-
rep(1/length(locationX[[S$tip.label[i]]]),
length(locationX[[S$tip.label[i]]]))
locationcols <- setNames(c("firebrick1", "dodgerblue1", "gold1", "grey15", "green", "white", "grey50"),
c("0", "1"))
par(fg="white")
location <- setNames(data$location, data$Synergus)
locationxx <- strsplit(as.character(location), split = "+", fixed = T)
locationpp <- matrix(0, length(location), 7, dimnames = list(names(location), c("leaf", "stem", "stem+leaf", "petiole+stem", "acorn", "bud", "bud+leaf+acorn")))
for (i in 1:nrow(locationpp)) locationpp[i,location[[i]]]<-1/length(location[[i]])
tiplabels(pie = locationpp, piecol = locationcols, cex=0.3)
par(fg="white")
piecol <- locationcols
for(i in 1:ncol(locationasr)){
locationnn <- strsplit(colnames(locationasr)[i],"+", fixed=TRUE)[[1]]
if(length(locationnn)==1) piecol[i] <- locationcols[locationnn]
else if(length(locationnn)==2) piecol[i] <- colorRampPalette(locationcols[locationnn])(3)[2]
else piecol[i]<-"black"
}
names(piecol)<-colnames(locationasr)
par(fg="white")
nodelabels(pie = locationasr, piecol = locationcols,cex=0.40)
par(fg="black")
legend("bottom", c(colnames(locationasr)), pch = 21, pt.bg = c("firebrick1", "dodgerblue1", "gold1", "grey15", "green", "white", "grey50"), pt.cex = 2, title = "location", cex = 1)
locationpp
#dev.off()
version
knitr::opts_chunk$set(echo = TRUE)
setwd("//wsl.localhost/Ubuntu/home/guerbrown/github_local/biol-4386-course-project-guerbrown/data/TraitModeling")
tree <- "//wsl.localhost/Ubuntu/home/guerbrown/github_local/biol-4386-course-project-guerbrown/data/TraitModeling/inqcophy_traitmodeling_SynTree_guerbrown.nex"
traits <- "//wsl.localhost/Ubuntu/home/guerbrown/github_local/biol-4386-course-project-guerbrown/data/TraitModeling/inqcophy_traitmodeling_TraitData_guerbrown.csv"
# Import
S <- readNexus(tree)
# Import
S <- readNexus(tree)
# Import
S <- readNexus(tree)
library(ape)
library(phytools)
library(geiger)
library(corHMM)
# Import
S <- readNexus(tree)
# Rooting the phylogeny based on a version of the tree with an outgroup and plotting
root.phylo(S, 28, resolve.root = T)
# Importing the .csv file with our traits
data <- read.csv(traits, row.names = 1)
# First, lets isolate the variable we want to graphically model from the original imported data frame
oak_section <- setNames(data$oak_section, rownames(data))
# Rename the levels of the variable
levels(oak_section) <- unique(data$oak_section)
# Recapitulation of the best fit model (see model selection script)
oak_section.ER <- fitpolyMk(S, oak_section, model = "ER")
# pull states off the fitted model object
oak_sectionxx <- apply(oak_section.ER$data,1,
function(x,ss) ss[which(x==1)],
ss=colnames(oak_section.ER$data))
# corHMM does not like to work with + so let's replace those with /
oak_sectionxx <- gsub("+","/", oak_sectionxx, fixed=TRUE)
# build corHMM data frame
oak_section.data <- data.frame(Genus_sp = names(oak_sectionxx), oak_section = oak_sectionxx)
# Pull out model design matrix from the fitted object
oak_section_rate.mat <- oak_section.ER$index.matrix
# Set any values of 0 in the design matrix to NA
oak_section_rate.mat[oak_section_rate.mat==0] <- NA
# Replace previous / with + in the new data design matrix
colnames(oak_section_rate.mat) <- rownames(oak_section_rate.mat) <- gsub("+","/", colnames(oak_section_rate.mat), fixed=TRUE)
# Order these from highest to lowest and name it something different that will allow us to transition the design matrix into something corHMM can utilize
oak_sectionind <- order(colnames(oak_section_rate.mat))
oak_section_rate.mat <- oak_section_rate.mat[oak_sectionind, oak_sectionind]
# Ancestral States (this part of the analysis is compiling everything we've extracted that has importance)
oak_section_fit.marginal <- corHMM(S, oak_section.data,
rate.mat = oak_section_rate.mat,
node.states = "marginal",
rate.cat = 1, p = oak_section.ER$rates,
root.p = oak_section.ER$pi)
# Marginal states are stores in $states. Extract this and ensure the model is consistent
oak_sectionasr <- oak_section_fit.marginal$states
colnames(oak_sectionasr) <- colnames(oak_section_rate.mat)
colnames(oak_sectionasr) <- gsub("/","+", colnames(oak_sectionasr))
# Prepare a graphical output for the phylogeny we are about to create
svg("/home/guerbrown/github_local/biol-4386-course-project-guerbrown/output/inqcophy_traitmodeling_oak_section_guerbrown.svg", width = 20, height = 10)
# Plot the tree in a phylo space with the layout of your choosing
plot.phylo(S, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
# Split the names of the trait so that the data frame recognizes traits with + as a combination of two or more traits
oak_sectionX <- strsplit(setNames(as.character(oak_section_rate.mat), names(oak_section_rate.mat)),"+", fixed=TRUE)
# Create pie charts of the traits you wish to graph on the tip labels. If you do not wish to represent a polymorphic trait as a discrete trait at tips, please run this **without** the code above.
pies <- matrix(0, Ntip(S),3,
dimnames=list(S$tip.label,
c("1", "2", "3")))
# Add data to the values for our pie charts
for(i in 1:Ntip(S))
pies[S$tip.label[i],
oak_sectionX[[S$tip.label[i]]]]<-
rep(1/length(oak_sectionX[[S$tip.label[i]]]),
length(oak_sectionX[[S$tip.label[i]]]))
# Provide a set of color variables that we can use later
oak_sectioncols <- setNames(c("firebrick1", "dodgerblue1", "grey15"),
c("Quercus", "Lobatae","Virentes"))
par(fg="white")
# Create a matrix of the trait and provide the names for its dimensions.
oak_sectionpp <- matrix(0, length(oak_section), 4, dimnames = list(names(oak_section), c("Lobatae","Quercus", "Virentes", "Quercus+Virentes")))
# Split combinational characters using split = "+". This allows each individual trait to be recognized independently and lets it combine with both combinational and noncombinational factors. Failure to include this results in inconsistencies in data frame size between the ...pp file and the ...xx file.
oak_sectionxx <- strsplit(as.character(oak_section), split = "+", fixed = T)
# Add data to this matrix. This line of code is a BEAST to understand. In short, it is adding values of the pp matrix from the xx data frame then dividing it so that we have proportional values based on a scale of 100. I say it is so complex because the spacing of the code is dense and there are a lot of specifiers one may not normally encounter. It is actually quite brilliant but I owe this to L. Revell, whose blog I adapted it from.
for (i in 1:nrow(oak_sectionpp)) oak_sectionpp[i,oak_sectionxx[[i]]]<-1/length(oak_sectionxx[[i]])
# Use the pp matrix to add pie charts to the terminal nodes of the phylogeny
tiplabels(pie = oak_sectionpp, piecol = oak_sectioncols, cex=0.3)
# Give them a white background for simplicity and beauty
par(fg="white")
piecol <- oak_sectioncols
# Now, we need to add the values for pie charts of internal nodes in the phylogeny. To do this, we will use our extracted states from the marginal states data frame. We will then create a second, newly split (/ instead of +) version of this data frame and where a particular value, or trait exists, we will provide that value with a length of 1. If it has another value, or trait, that is a combination of traits we will give it a length of 2 and then produce a color pallet from mixing the colors of the traits that it is a combination of. So, if a trait is made of two traits, a red and a blue trait, the mixture of the two is represented as purple.
for(i in 1:ncol(oak_sectionasr)){
oak_sectionnn <- strsplit(colnames(oak_sectionasr)[i],"+", fixed=TRUE)[[1]]
if(length(oak_sectionnn)==1) piecol[i] <- oak_sectioncols[oak_sectionnn]
else if(length(oak_sectionnn)==2) piecol[i] <- colorRampPalette(oak_sectioncols[oak_sectionnn])(3)[2]
else piecol[i]<-"black"
}
# Now, provide the names of the pies using the column names of the modified ...asr data frame
names(piecol) <- colnames(oak_sectionasr)
par(fg="white")
# Finally! We can plot the pie charts of the nodes!
nodelabels(pie = oak_sectionasr, piecol = oak_sectioncols,cex=0.40)
par(fg="black")
# And lastly, provide a legend
legend("bottom", c(colnames(oak_sectionasr)), pch = 21, pt.bg = c("firebrick1", "dodgerblue1", "grey15", "yellow", "green", "orange", "black"), pt.cex = 2, title = "Oak Section", cex = 1)
# Now that we have plotted the object, we need to tell the code to stop saving graphics as an svg.
dev.off()
# First, lets isolate the variable we want to graphically model from the original imported data frame
oak_section <- setNames(data$oak_section, rownames(data))
# Rename the levels of the variable
levels(oak_section) <- unique(data$oak_section)
# Recapitulation of the best fit model (see model selection script)
oak_section.ER <- fitpolyMk(S, oak_section, model = "ER")
# pull states off the fitted model object
oak_sectionxx <- apply(oak_section.ER$data,1,
function(x,ss) ss[which(x==1)],
ss=colnames(oak_section.ER$data))
# corHMM does not like to work with + so let's replace those with /
oak_sectionxx <- gsub("+","/", oak_sectionxx, fixed=TRUE)
# build corHMM data frame
oak_section.data <- data.frame(Genus_sp = names(oak_sectionxx), oak_section = oak_sectionxx)
# Pull out model design matrix from the fitted object
oak_section_rate.mat <- oak_section.ER$index.matrix
# Set any values of 0 in the design matrix to NA
oak_section_rate.mat[oak_section_rate.mat==0] <- NA
# Replace previous / with + in the new data design matrix
colnames(oak_section_rate.mat) <- rownames(oak_section_rate.mat) <- gsub("+","/", colnames(oak_section_rate.mat), fixed=TRUE)
# Order these from highest to lowest and name it something different that will allow us to transition the design matrix into something corHMM can utilize
oak_sectionind <- order(colnames(oak_section_rate.mat))
oak_section_rate.mat <- oak_section_rate.mat[oak_sectionind, oak_sectionind]
# Ancestral States (this part of the analysis is compiling everything we've extracted that has importance)
oak_section_fit.marginal <- corHMM(S, oak_section.data,
rate.mat = oak_section_rate.mat,
node.states = "marginal",
rate.cat = 1, p = oak_section.ER$rates,
root.p = oak_section.ER$pi)
# Marginal states are stores in $states. Extract this and ensure the model is consistent
oak_sectionasr <- oak_section_fit.marginal$states
colnames(oak_sectionasr) <- colnames(oak_section_rate.mat)
colnames(oak_sectionasr) <- gsub("/","+", colnames(oak_sectionasr))
# Prepare a graphical output for the phylogeny we are about to create
# svg("/home/guerbrown/github_local/biol-4386-course-project-guerbrown/output/inqcophy_traitmodeling_oak_section_guerbrown.svg", width = 20, height = 10)
# Plot the tree in a phylo space with the layout of your choosing
plot.phylo(S, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
# Split the names of the trait so that the data frame recognizes traits with + as a combination of two or more traits
oak_sectionX <- strsplit(setNames(as.character(oak_section_rate.mat), names(oak_section_rate.mat)),"+", fixed=TRUE)
# Create pie charts of the traits you wish to graph on the tip labels. If you do not wish to represent a polymorphic trait as a discrete trait at tips, please run this **without** the code above.
pies <- matrix(0, Ntip(S),3,
dimnames=list(S$tip.label,
c("1", "2", "3")))
# Add data to the values for our pie charts
for(i in 1:Ntip(S))
pies[S$tip.label[i],
oak_sectionX[[S$tip.label[i]]]]<-
rep(1/length(oak_sectionX[[S$tip.label[i]]]),
length(oak_sectionX[[S$tip.label[i]]]))
# Provide a set of color variables that we can use later
oak_sectioncols <- setNames(c("firebrick1", "dodgerblue1", "grey15", "yellow"),
c("Lobatae","Quercus", "Virentes", "Quercus+Virentes"))
par(fg="white")
# Create a matrix of the trait and provide the names for its dimensions.
oak_sectionpp <- matrix(0, length(oak_section), 4, dimnames = list(names(oak_section), c("Lobatae","Quercus", "Virentes", "Quercus+Virentes")))
# Split combinational characters using split = "+". This allows each individual trait to be recognized independently and lets it combine with both combinational and noncombinational factors. Failure to include this results in inconsistencies in data frame size between the ...pp file and the ...xx file.
oak_sectionxx <- strsplit(as.character(oak_section), split = "+", fixed = T)
# Add data to this matrix. This line of code is a BEAST to understand. In short, it is adding values of the pp matrix from the xx data frame then dividing it so that we have proportional values based on a scale of 100. I say it is so complex because the spacing of the code is dense and there are a lot of specifiers one may not normally encounter. It is actually quite brilliant but I owe this to L. Revell, whose blog I adapted it from.
for (i in 1:nrow(oak_sectionpp)) oak_sectionpp[i,oak_sectionxx[[i]]]<-1/length(oak_sectionxx[[i]])
# Use the pp matrix to add pie charts to the terminal nodes of the phylogeny
tiplabels(pie = oak_sectionpp, piecol = oak_sectioncols, cex=0.3)
# Give them a white background for simplicity and beauty
par(fg="white")
piecol <- oak_sectioncols
# Now, we need to add the values for pie charts of internal nodes in the phylogeny. To do this, we will use our extracted states from the marginal states data frame. We will then create a second, newly split (/ instead of +) version of this data frame and where a particular value, or trait exists, we will provide that value with a length of 1. If it has another value, or trait, that is a combination of traits we will give it a length of 2 and then produce a color pallet from mixing the colors of the traits that it is a combination of. So, if a trait is made of two traits, a red and a blue trait, the mixture of the two is represented as purple.
for(i in 1:ncol(oak_sectionasr)){
oak_sectionnn <- strsplit(colnames(oak_sectionasr)[i],"+", fixed=TRUE)[[1]]
if(length(oak_sectionnn)==1) piecol[i] <- oak_sectioncols[oak_sectionnn]
else if(length(oak_sectionnn)==2) piecol[i] <- colorRampPalette(oak_sectioncols[oak_sectionnn])(3)[2]
else piecol[i]<-"black"
}
# Now, provide the names of the pies using the column names of the modified ...asr data frame
names(piecol) <- colnames(oak_sectionasr)
par(fg="white")
# Finally! We can plot the pie charts of the nodes!
nodelabels(pie = oak_sectionasr, piecol = oak_sectioncols,cex=0.40)
par(fg="black")
# And lastly, provide a legend
legend("bottom", c("Lobatae","Quercus", "Virentes", "Quercus+Virentes"), pch = 21, pt.bg = c("firebrick1", "dodgerblue1", "grey15", "yellow"), pt.cex = 2, title = "Oak Section", cex = 1)
# Now that we have plotted the object, we need to tell the code to stop saving graphics as an svg.
#dev.off()
# First, lets isolate the variable we want to graphically model from the original imported data frame
oak_section <- setNames(data$oak_section, rownames(data))
# Rename the levels of the variable
levels(oak_section) <- unique(data$oak_section)
# Recapitulation of the best fit model (see model selection script)
oak_section.ER <- fitpolyMk(S, oak_section, model = "ER")
# pull states off the fitted model object
oak_sectionxx <- apply(oak_section.ER$data,1,
function(x,ss) ss[which(x==1)],
ss=colnames(oak_section.ER$data))
# corHMM does not like to work with + so let's replace those with /
oak_sectionxx <- gsub("+","/", oak_sectionxx, fixed=TRUE)
# build corHMM data frame
oak_section.data <- data.frame(Genus_sp = names(oak_sectionxx), oak_section = oak_sectionxx)
# Pull out model design matrix from the fitted object
oak_section_rate.mat <- oak_section.ER$index.matrix
# Set any values of 0 in the design matrix to NA
oak_section_rate.mat[oak_section_rate.mat==0] <- NA
# Replace previous / with + in the new data design matrix
colnames(oak_section_rate.mat) <- rownames(oak_section_rate.mat) <- gsub("+","/", colnames(oak_section_rate.mat), fixed=TRUE)
# Order these from highest to lowest and name it something different that will allow us to transition the design matrix into something corHMM can utilize
oak_sectionind <- order(colnames(oak_section_rate.mat))
oak_section_rate.mat <- oak_section_rate.mat[oak_sectionind, oak_sectionind]
# Ancestral States (this part of the analysis is compiling everything we've extracted that has importance)
oak_section_fit.marginal <- corHMM(S, oak_section.data,
rate.mat = oak_section_rate.mat,
node.states = "marginal",
rate.cat = 1, p = oak_section.ER$rates,
root.p = oak_section.ER$pi)
# Marginal states are stores in $states. Extract this and ensure the model is consistent
oak_sectionasr <- oak_section_fit.marginal$states
colnames(oak_sectionasr) <- colnames(oak_section_rate.mat)
colnames(oak_sectionasr) <- gsub("/","+", colnames(oak_sectionasr))
# Prepare a graphical output for the phylogeny we are about to create
svg("/home/guerbrown/github_local/biol-4386-course-project-guerbrown/output/inqcophy_traitmodeling_oak_section_guerbrown.svg", width = 20, height = 10)
# Plot the tree in a phylo space with the layout of your choosing
plot.phylo(S, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
# Split the names of the trait so that the data frame recognizes traits with + as a combination of two or more traits
oak_sectionX <- strsplit(setNames(as.character(oak_section_rate.mat), names(oak_section_rate.mat)),"+", fixed=TRUE)
# Create pie charts of the traits you wish to graph on the tip labels. If you do not wish to represent a polymorphic trait as a discrete trait at tips, please run this **without** the code above.
pies <- matrix(0, Ntip(S),3,
dimnames=list(S$tip.label,
c("1", "2", "3")))
# Add data to the values for our pie charts
for(i in 1:Ntip(S))
pies[S$tip.label[i],
oak_sectionX[[S$tip.label[i]]]]<-
rep(1/length(oak_sectionX[[S$tip.label[i]]]),
length(oak_sectionX[[S$tip.label[i]]]))
# Provide a set of color variables that we can use later
oak_sectioncols <- setNames(c("firebrick1", "dodgerblue1", "grey15", "yellow"),
c("Lobatae","Quercus", "Virentes", "Quercus+Virentes"))
par(fg="white")
# Create a matrix of the trait and provide the names for its dimensions.
oak_sectionpp <- matrix(0, length(oak_section), 4, dimnames = list(names(oak_section), c("Lobatae","Quercus", "Virentes", "Quercus+Virentes")))
# Split combinational characters using split = "+". This allows each individual trait to be recognized independently and lets it combine with both combinational and noncombinational factors. Failure to include this results in inconsistencies in data frame size between the ...pp file and the ...xx file.
oak_sectionxx <- strsplit(as.character(oak_section), split = "+", fixed = T)
# Add data to this matrix. This line of code is a BEAST to understand. In short, it is adding values of the pp matrix from the xx data frame then dividing it so that we have proportional values based on a scale of 100. I say it is so complex because the spacing of the code is dense and there are a lot of specifiers one may not normally encounter. It is actually quite brilliant but I owe this to L. Revell, whose blog I adapted it from.
for (i in 1:nrow(oak_sectionpp)) oak_sectionpp[i,oak_sectionxx[[i]]]<-1/length(oak_sectionxx[[i]])
# Use the pp matrix to add pie charts to the terminal nodes of the phylogeny
tiplabels(pie = oak_sectionpp, piecol = oak_sectioncols, cex=0.3)
# Give them a white background for simplicity and beauty
par(fg="white")
piecol <- oak_sectioncols
# Now, we need to add the values for pie charts of internal nodes in the phylogeny. To do this, we will use our extracted states from the marginal states data frame. We will then create a second, newly split (/ instead of +) version of this data frame and where a particular value, or trait exists, we will provide that value with a length of 1. If it has another value, or trait, that is a combination of traits we will give it a length of 2 and then produce a color pallet from mixing the colors of the traits that it is a combination of. So, if a trait is made of two traits, a red and a blue trait, the mixture of the two is represented as purple.
for(i in 1:ncol(oak_sectionasr)){
oak_sectionnn <- strsplit(colnames(oak_sectionasr)[i],"+", fixed=TRUE)[[1]]
if(length(oak_sectionnn)==1) piecol[i] <- oak_sectioncols[oak_sectionnn]
else if(length(oak_sectionnn)==2) piecol[i] <- colorRampPalette(oak_sectioncols[oak_sectionnn])(3)[2]
else piecol[i]<-"black"
}
# Now, provide the names of the pies using the column names of the modified ...asr data frame
names(piecol) <- colnames(oak_sectionasr)
par(fg="white")
# Finally! We can plot the pie charts of the nodes!
nodelabels(pie = oak_sectionasr, piecol = oak_sectioncols,cex=0.40)
par(fg="black")
# And lastly, provide a legend
legend("bottom", c("Lobatae","Quercus", "Virentes", "Quercus+Virentes"), pch = 21, pt.bg = c("firebrick1", "dodgerblue1", "grey15", "yellow"), pt.cex = 2, title = "Oak Section", cex = 1)
# Now that we have plotted the object, we need to tell the code to stop saving graphics as an svg.
dev.off()
# First, lets isolate the variable we want to graphically model from the original imported data frame
oak_section <- setNames(data$oak_section, rownames(data))
# Rename the levels of the variable
levels(oak_section) <- unique(data$oak_section)
# Recapitulation of the best fit model (see model selection script)
oak_section.ER <- fitpolyMk(S, oak_section, model = "ER")
# pull states off the fitted model object
oak_sectionxx <- apply(oak_section.ER$data,1,
function(x,ss) ss[which(x==1)],
ss=colnames(oak_section.ER$data))
# corHMM does not like to work with + so let's replace those with /
oak_sectionxx <- gsub("+","/", oak_sectionxx, fixed=TRUE)
# build corHMM data frame
oak_section.data <- data.frame(Genus_sp = names(oak_sectionxx), oak_section = oak_sectionxx)
# Pull out model design matrix from the fitted object
oak_section_rate.mat <- oak_section.ER$index.matrix
# Set any values of 0 in the design matrix to NA
oak_section_rate.mat[oak_section_rate.mat==0] <- NA
# Replace previous / with + in the new data design matrix
colnames(oak_section_rate.mat) <- rownames(oak_section_rate.mat) <- gsub("+","/", colnames(oak_section_rate.mat), fixed=TRUE)
# Order these from highest to lowest and name it something different that will allow us to transition the design matrix into something corHMM can utilize
oak_sectionind <- order(colnames(oak_section_rate.mat))
oak_section_rate.mat <- oak_section_rate.mat[oak_sectionind, oak_sectionind]
# Ancestral States (this part of the analysis is compiling everything we've extracted that has importance)
oak_section_fit.marginal <- corHMM(S, oak_section.data,
rate.mat = oak_section_rate.mat,
node.states = "marginal",
rate.cat = 1, p = oak_section.ER$rates,
root.p = oak_section.ER$pi)
# Marginal states are stores in $states. Extract this and ensure the model is consistent
oak_sectionasr <- oak_section_fit.marginal$states
colnames(oak_sectionasr) <- colnames(oak_section_rate.mat)
colnames(oak_sectionasr) <- gsub("/","+", colnames(oak_sectionasr))
# Prepare a graphical output for the phylogeny we are about to create
svg("/home/guerbrown/github_local/biol-4386-course-project-guerbrown/output/inqcophy_traitmodeling_oak_section_guerbrown.svg", width = 20, height = 10)
# Plot the tree in a phylo space with the layout of your choosing
plot.phylo(S, type = "fan", cex = 1.1, align.tip.label = F, lwd = 2, label.offset = 0.05, use.edge.length = F, open.angle =  163, node.depth = 100)
# Split the names of the trait so that the data frame recognizes traits with + as a combination of two or more traits
oak_sectionX <- strsplit(setNames(as.character(oak_section_rate.mat), names(oak_section_rate.mat)),"+", fixed=TRUE)
# Create pie charts of the traits you wish to graph on the tip labels. If you do not wish to represent a polymorphic trait as a discrete trait at tips, please run this **without** the code above.
pies <- matrix(0, Ntip(S),3,
dimnames=list(S$tip.label,
c("1", "2", "3")))
# Add data to the values for our pie charts
for(i in 1:Ntip(S))
pies[S$tip.label[i],
oak_sectionX[[S$tip.label[i]]]]<-
rep(1/length(oak_sectionX[[S$tip.label[i]]]),
length(oak_sectionX[[S$tip.label[i]]]))
# Provide a set of color variables that we can use later
oak_sectioncols <- setNames(c("firebrick1", "dodgerblue1", "grey15", "yellow"),
c("Lobatae","Quercus", "Virentes", "Quercus+Virentes"))
par(fg="white")
# Create a matrix of the trait and provide the names for its dimensions.
oak_sectionpp <- matrix(0, length(oak_section), 4, dimnames = list(names(oak_section), c("Lobatae","Quercus", "Virentes", "Quercus+Virentes")))
# Split combinational characters using split = "+". This allows each individual trait to be recognized independently and lets it combine with both combinational and noncombinational factors. Failure to include this results in inconsistencies in data frame size between the ...pp file and the ...xx file.
oak_sectionxx <- strsplit(as.character(oak_section), split = "+", fixed = T)
# Add data to this matrix. This line of code is a BEAST to understand. In short, it is adding values of the pp matrix from the xx data frame then dividing it so that we have proportional values based on a scale of 100. I say it is so complex because the spacing of the code is dense and there are a lot of specifiers one may not normally encounter. It is actually quite brilliant but I owe this to L. Revell, whose blog I adapted it from.
for (i in 1:nrow(oak_sectionpp)) oak_sectionpp[i,oak_sectionxx[[i]]]<-1/length(oak_sectionxx[[i]])
# Use the pp matrix to add pie charts to the terminal nodes of the phylogeny
tiplabels(pie = oak_sectionpp, piecol = oak_sectioncols, cex=0.3)
# Give them a white background for simplicity and beauty
par(fg="white")
piecol <- oak_sectioncols
# Now, we need to add the values for pie charts of internal nodes in the phylogeny. To do this, we will use our extracted states from the marginal states data frame. We will then create a second, newly split (/ instead of +) version of this data frame and where a particular value, or trait exists, we will provide that value with a length of 1. If it has another value, or trait, that is a combination of traits we will give it a length of 2 and then produce a color pallet from mixing the colors of the traits that it is a combination of. So, if a trait is made of two traits, a red and a blue trait, the mixture of the two is represented as purple.
for(i in 1:ncol(oak_sectionasr)){
oak_sectionnn <- strsplit(colnames(oak_sectionasr)[i],"+", fixed=TRUE)[[1]]
if(length(oak_sectionnn)==1) piecol[i] <- oak_sectioncols[oak_sectionnn]
else if(length(oak_sectionnn)==2) piecol[i] <- colorRampPalette(oak_sectioncols[oak_sectionnn])(3)[2]
else piecol[i]<-"black"
}
# Now, provide the names of the pies using the column names of the modified ...asr data frame
names(piecol) <- colnames(oak_sectionasr)
par(fg="white")
# Finally! We can plot the pie charts of the nodes!
nodelabels(pie = oak_sectionasr, piecol = oak_sectioncols,cex=0.40)
par(fg="black")
# And lastly, provide a legend
legend("bottom", c("Lobatae","Quercus", "Virentes"), pch = 21, pt.bg = c("firebrick1", "dodgerblue1", "grey15"), pt.cex = 2, title = "Oak Section", cex = 1)
# Now that we have plotted the object, we need to tell the code to stop saving graphics as an svg.
dev.off()
